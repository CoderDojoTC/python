{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoderDojo Twin Cities Python Resources This GitHub repository is for sharing teaching resources to teach Python. This includes hints on getting your Python environments setup up and extensive lesson plans for serveral enviornments. Our mentors have used several different envornments for teaching Python. They each have pros and cons. What our mentors like is getting new students started using a graphical programming environment such as turtle graphics libraries. Here are some of our favorite tools: Trinket.io is an easy-to use, kid friendly web-based turtle graphics for beginners. Jupyter Notebooks also have some support for turtle graphics. Jupyter Notebooks can be tricky to setup for the first time, but they are the perfect on-ramp for teaching data literacy. Raspberry Pi - The Raspberry Pi foundation has selected Python as its primary tool for teaching programming. If you have a Raspberry Pi there are many resources for you. Trinket and Jupyter Notebooks will also run on many Raspberry Pi devices. Robots Our students love robots. Python is also the preferred language in many robotics courses. Today we teach beginning robotics with Scratch and Arduino, but we continue to investigate systems like Raspberry Pi robots that can be programmed with Python. Let us know if you have any low-cost kid friendly ideas. We have tested the JetBot and other robots and we continue to look for solutions. Now lets briefly go into the pros and cons of these systems. Learning Python with Trinket We use the trinket.io web site to teach our introduction to python. Trinket has a nice turtle graphics library which is ideal for fast visual feedback. Because it is a free and a pure web web based environment it meets the criteria for our courses. There is no complex setup and each student can continue to do development when they are at home. The downside of Trinket is it has limited functionality, only supports Python 2.X in the free version and you must have an internet connection to use Trinket. If you need Python 3.X web version you can use the free repl.id web site. Learning Python with Jupyter Notebooks You can also use Jupyter Notebooks to draw turtle graphics. The notebook will open a new window to draw your turtle graphis. Getting Jupyter Notebooks is a bit tricky to setup on many PCs. However, once it is setup it offers tens of thousands of sample programs to learn python coding. Jupyter Notebooks are also the preferred tool by many data science professionals. An example of a Jupyter Notebook that uses turtle graphs is here Learning Python with Raspberry Pi If you have a Rasperry Pi there are many great ways to learn Python. One of first things is to try out one of the Python development environments for the Raspberry Pi. Learning Python with Robots Right now we are continuing to try to find the right combination of easy-of-use and low-cost robots to teach python. If you hear of any good tools, please let us know. Target Audience Learning Python is ideal for students that have good keyboarding skills. If students have difficulty with doing functions like copy and pasting text we suggest they start with a block-programming language like Scratch. List of Concepts Here are some of the concepts we will be learning in this course. If you are already familiar with these concepts you can skip over some of the labs. importing libraries We need to tell Pyhton what functions we want to use. We will use the import function to tell Python which functions we need to use in our programs. drawing Turtle graphs has a set of drawing functions. We will learn to use these to draw patterns on the screen. square walk - teach your turtle to walk in a square and draw figures. variables Variables make our programs easier to read and easier to understand. loops Loops help use when we have many tasks that we repeat over and over. conditionals Conditionals allow us to change our behavior based on rules we create. functions Functions allow us to break large programs into chunks that we can give names and can call over and over. function parameters Functions can also take parameters to change the behavior of a function. random numbers Random number functions allow our programs to have the computer select new random number between a range of numbers. lists Lists alow us to create collections of names. inputs Inputs allow us to prompt the user for values. recursion Recursion allows us to have programs call themselves to create repeating patterns. modules Once you have a group of related functions you can put them all together into a module. This makes it easier for others to reuse your programs. Contributing to Our Library Do you have a specific example you would like to share with other students and teachers? Please see the Contributing menu for details on how to share your code.","title":"CoderDojo Twin Cities Python Resources"},{"location":"#coderdojo-twin-cities-python-resources","text":"This GitHub repository is for sharing teaching resources to teach Python. This includes hints on getting your Python environments setup up and extensive lesson plans for serveral enviornments. Our mentors have used several different envornments for teaching Python. They each have pros and cons. What our mentors like is getting new students started using a graphical programming environment such as turtle graphics libraries. Here are some of our favorite tools: Trinket.io is an easy-to use, kid friendly web-based turtle graphics for beginners. Jupyter Notebooks also have some support for turtle graphics. Jupyter Notebooks can be tricky to setup for the first time, but they are the perfect on-ramp for teaching data literacy. Raspberry Pi - The Raspberry Pi foundation has selected Python as its primary tool for teaching programming. If you have a Raspberry Pi there are many resources for you. Trinket and Jupyter Notebooks will also run on many Raspberry Pi devices. Robots Our students love robots. Python is also the preferred language in many robotics courses. Today we teach beginning robotics with Scratch and Arduino, but we continue to investigate systems like Raspberry Pi robots that can be programmed with Python. Let us know if you have any low-cost kid friendly ideas. We have tested the JetBot and other robots and we continue to look for solutions. Now lets briefly go into the pros and cons of these systems.","title":"CoderDojo Twin Cities Python Resources"},{"location":"#learning-python-with-trinket","text":"We use the trinket.io web site to teach our introduction to python. Trinket has a nice turtle graphics library which is ideal for fast visual feedback. Because it is a free and a pure web web based environment it meets the criteria for our courses. There is no complex setup and each student can continue to do development when they are at home. The downside of Trinket is it has limited functionality, only supports Python 2.X in the free version and you must have an internet connection to use Trinket. If you need Python 3.X web version you can use the free repl.id web site.","title":"Learning Python with Trinket"},{"location":"#learning-python-with-jupyter-notebooks","text":"You can also use Jupyter Notebooks to draw turtle graphics. The notebook will open a new window to draw your turtle graphis. Getting Jupyter Notebooks is a bit tricky to setup on many PCs. However, once it is setup it offers tens of thousands of sample programs to learn python coding. Jupyter Notebooks are also the preferred tool by many data science professionals. An example of a Jupyter Notebook that uses turtle graphs is here","title":"Learning Python with Jupyter Notebooks"},{"location":"#learning-python-with-raspberry-pi","text":"If you have a Rasperry Pi there are many great ways to learn Python. One of first things is to try out one of the Python development environments for the Raspberry Pi.","title":"Learning Python with Raspberry Pi"},{"location":"#learning-python-with-robots","text":"Right now we are continuing to try to find the right combination of easy-of-use and low-cost robots to teach python. If you hear of any good tools, please let us know.","title":"Learning Python with Robots"},{"location":"#target-audience","text":"Learning Python is ideal for students that have good keyboarding skills. If students have difficulty with doing functions like copy and pasting text we suggest they start with a block-programming language like Scratch.","title":"Target Audience"},{"location":"#list-of-concepts","text":"Here are some of the concepts we will be learning in this course. If you are already familiar with these concepts you can skip over some of the labs. importing libraries We need to tell Pyhton what functions we want to use. We will use the import function to tell Python which functions we need to use in our programs. drawing Turtle graphs has a set of drawing functions. We will learn to use these to draw patterns on the screen. square walk - teach your turtle to walk in a square and draw figures. variables Variables make our programs easier to read and easier to understand. loops Loops help use when we have many tasks that we repeat over and over. conditionals Conditionals allow us to change our behavior based on rules we create. functions Functions allow us to break large programs into chunks that we can give names and can call over and over. function parameters Functions can also take parameters to change the behavior of a function. random numbers Random number functions allow our programs to have the computer select new random number between a range of numbers. lists Lists alow us to create collections of names. inputs Inputs allow us to prompt the user for values. recursion Recursion allows us to have programs call themselves to create repeating patterns. modules Once you have a group of related functions you can put them all together into a module. This makes it easier for others to reuse your programs.","title":"List of Concepts"},{"location":"#contributing-to-our-library","text":"Do you have a specific example you would like to share with other students and teachers? Please see the Contributing menu for details on how to share your code.","title":"Contributing to Our Library"},{"location":"contact/","text":"Contacts General Code Savvy Contact kidscode@codesavvy.org Specific questions on this repository Dan McCreary Dan.McCreary@gmail.com","title":"Contact"},{"location":"contact/#contacts","text":"","title":"Contacts"},{"location":"contact/#general-code-savvy-contact","text":"kidscode@codesavvy.org","title":"General Code Savvy Contact"},{"location":"contact/#specific-questions-on-this-repository","text":"Dan McCreary Dan.McCreary@gmail.com","title":"Specific questions on this repository"},{"location":"contribute/","text":"How to Contribute to Our Learning Python Library We are an all-volunteer organization. So we don't yet have any paid staff to curate new content. However, we do value your input and will consider all contributions as our volunteer time permits. We especially value teachers that would like to integrate coding, data science and AI into your classrooms in new and innovative ways. Using Standard Git Pull Requests The best way to contribute is to send use your sample programs using a standard GitHub pull request method. This allow us to view all the changes you are proposing and give you feedback. This is a three step process. 1. The first step will require you to have your own github account. You can go to our github home page and look for the \"fork\" icon. When you click that it will make a \"virutal copy\" in your own github area. 2. You can then add your content to that repository and do all the testing there. 3. Once you have everything tested you can click the \"Submit Pull Request\". This process will notify our team your additon is pending. We will review these new submission and if everything looks OK we will accept your changes. We might suggest a few changes the first time you send us a pull request. Don't take this personally. We want to make working on-line togeher as semaless as possible and helping put the right sections in place to start is a normal part of working in teams on line. Good Lesson Plans A good contribution has some, but not necessarily all of the following: Context - where does this lession fit into our overall cirriculum? Would it normally follow after an existing lession or is it a standalone lesson? Concepts - what concept will be taught in this lesson. We try to keep to the idea of \"One concept per lesson\". So think about what is the minimum amount of code to learn a new concept. Learning Objective - what are the goals of this lession. These are typically written as \"After this lesson the student...: Difficulty Level - is it a Beginner, Intermediate or Difficult concept? For example drawing a square with a turtle is a Beginner concept. Recursion is a Difficult concept. Sample Code - Please provide working sample code that you have tested whenever possible. We encourage you to put in in-line comments when possible. To use our test highlighter for Python code, please place your code in a block sourrounded by back quotes. Use the word \"python\" on the like with the first backquotes. See Examples Here Experiments - What additional experiments could the students do? Could they intergrate other prior concepts? Using Markdown formats We strongly suggest you submit your contributions using Markdown format. There are tools that will convert MS-Word into Markdown format. See the Markdown Cheat Sheet for tips to get started with Markdown. Converting MS-Word to Markdown format If you have content in Microsoft Word and you use a Windows PC, you can use the Writage plugin to convert your documents. For Mac users you can use the PanDoc program to convert MS-Word into Markdown. You will need to open a Terminal to run the following command: $ pandoc -s MyFile.docx -o MyFile.md","title":"How to Contribute Examples"},{"location":"contribute/#how-to-contribute-to-our-learning-python-library","text":"We are an all-volunteer organization. So we don't yet have any paid staff to curate new content. However, we do value your input and will consider all contributions as our volunteer time permits. We especially value teachers that would like to integrate coding, data science and AI into your classrooms in new and innovative ways.","title":"How to Contribute to Our Learning Python Library"},{"location":"contribute/#using-standard-git-pull-requests","text":"The best way to contribute is to send use your sample programs using a standard GitHub pull request method. This allow us to view all the changes you are proposing and give you feedback. This is a three step process. 1. The first step will require you to have your own github account. You can go to our github home page and look for the \"fork\" icon. When you click that it will make a \"virutal copy\" in your own github area. 2. You can then add your content to that repository and do all the testing there. 3. Once you have everything tested you can click the \"Submit Pull Request\". This process will notify our team your additon is pending. We will review these new submission and if everything looks OK we will accept your changes. We might suggest a few changes the first time you send us a pull request. Don't take this personally. We want to make working on-line togeher as semaless as possible and helping put the right sections in place to start is a normal part of working in teams on line.","title":"Using Standard Git Pull Requests"},{"location":"contribute/#good-lesson-plans","text":"A good contribution has some, but not necessarily all of the following: Context - where does this lession fit into our overall cirriculum? Would it normally follow after an existing lession or is it a standalone lesson? Concepts - what concept will be taught in this lesson. We try to keep to the idea of \"One concept per lesson\". So think about what is the minimum amount of code to learn a new concept. Learning Objective - what are the goals of this lession. These are typically written as \"After this lesson the student...: Difficulty Level - is it a Beginner, Intermediate or Difficult concept? For example drawing a square with a turtle is a Beginner concept. Recursion is a Difficult concept. Sample Code - Please provide working sample code that you have tested whenever possible. We encourage you to put in in-line comments when possible. To use our test highlighter for Python code, please place your code in a block sourrounded by back quotes. Use the word \"python\" on the like with the first backquotes. See Examples Here Experiments - What additional experiments could the students do? Could they intergrate other prior concepts?","title":"Good Lesson Plans"},{"location":"contribute/#using-markdown-formats","text":"We strongly suggest you submit your contributions using Markdown format. There are tools that will convert MS-Word into Markdown format. See the Markdown Cheat Sheet for tips to get started with Markdown.","title":"Using Markdown formats"},{"location":"contribute/#converting-ms-word-to-markdown-format","text":"If you have content in Microsoft Word and you use a Windows PC, you can use the Writage plugin to convert your documents. For Mac users you can use the PanDoc program to convert MS-Word into Markdown. You will need to open a Terminal to run the following command: $ pandoc -s MyFile.docx -o MyFile.md","title":"Converting MS-Word to Markdown format"},{"location":"references/","text":"University of Western CoderDojo at University of Western Australia - Class of 2016 https://github.com/rckc/CoderDojoUWA2016","title":"References"},{"location":"advanced/mnist/","text":"Handwritten Digit Classification We will program and train a machine learning model to recognize handwritten numbers. The code for this lesson can be found here . But What Is Machine Learnig? Process of determining the function that gives a plausible result y for a set of inputs, in form of a vector x . In its simplest form, this could be linear regression, where we find the line of best fit through the data. In more complex forms, however, this can be training a neural network to fit very non-linear data. We will use a type of neural network to recognize our handwritten numbers. Types of Neural Networks As you can see, there are many different types, or architectures of neural networks. Some of the most common are Feed Forward, Recurrent, LSTM, and AutoEncoder neural networks. The other most common is the one that we will use, or a Convolutional Neural Network. Convolutional Neural Network Since we have image data, we will use a Convolutional Neural Network (CNN). A CNN works by sliding \"windows\" over the input image and aggregating nearby pixels together. Importing Packages For this project, we will be using a machine learning package called Keras. This makes it really easy to construct our neural network. We also import matplotlib to visualize our data, and numpy for some utilities. import keras from keras.datasets import mnist # Get dataset from keras.models import Sequential from keras.layers import Dense , Dropout , Flatten # Need these types of layers from keras.layers import Conv2D , MaxPooling2D # Need convolutional layers import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np Loading Data Important to load both a training and testing set to make sure the CNN is not \"memorizing\" the set of images it will train on. This would lead to awful accuracy in the \"real world\" # input image dimensions (pixels) img_rows , img_cols = 28 , 28 # the data, split between train and test sets ( x_train , y_train ), ( x_test , y_test ) = mnist . load_data () # manipulate the data for the CNN x_train = x_train . reshape ( x_train . shape [ 0 ], img_rows , img_cols , 1 ) x_test = x_test . reshape ( x_test . shape [ 0 ], img_rows , img_cols , 1 ) input_shape = ( img_rows , img_cols , 1 ) Preprocessing Data We want to have our CNN work with numbers between 0 and 1. Since pixel values are from 0-255, we divide all numbers by 255 in order to make them between 0 and 1. We then can see how many training and testing samples we have. x_train = x_train . astype ( 'float32' ) x_test = x_test . astype ( 'float32' ) x_train /= 255 x_test /= 255 print ( 'x_train shape:' , x_train . shape ) print ( x_train . shape [ 0 ], 'train samples' ) print ( x_test . shape [ 0 ], 'test samples' ) Look At Data In the next few cells, we will look at an example of a digit and see what number it is in the training set. x_train [ 0 ] pixels = x_train [ 0 ] . reshape (( 28 , 28 )) plt . imshow ( pixels , cmap = 'gray' ) print ( y_train [ 0 ]) Desired Output We want to convert the desired output from a number n to a vector where the nth element is 1 and the rest are 0. Example: n = 5 Resulting Vector = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0} num_classes = 10 y_train = keras . utils . to_categorical ( y_train , num_classes ) y_test = keras . utils . to_categorical ( y_test , num_classes ) Define Model Now here is the fun part. Building the model! We will have a 5 layer neural network. Feel free to play around with some of the parameters and see what works better or worse! model = Sequential () model . add ( Conv2D ( 32 , kernel_size = ( 3 , 3 ), activation = 'relu' , input_shape = input_shape )) model . add ( Conv2D ( 64 , ( 3 , 3 ), activation = 'relu' )) model . add ( MaxPooling2D ( pool_size = ( 2 , 2 ))) model . add ( Dropout ( 0.25 )) # Prevent overfitting model . add ( Flatten ()) model . add ( Dense ( 128 , activation = 'relu' )) model . add ( Dropout ( 0.5 )) model . add ( Dense ( num_classes , activation = 'softmax' )) model . summary () Set Parameters Here, we will set two parameters for the network. The first is batch size, which determines how many training examples we will look at before changing the weights in the model. We will also set the number of epochs, or iterations through the entire training set. batch_size = 128 # How many training examples will we look at before updating the weights in the matrix epochs = 12 # How many times we will run through the complete training set Compile and Train Model Here, we compile the model and then train it. A couple things to note. We are using the Adam optimizer, as compared to others such as stochastic gradient descent. We are measuring the success of the model through the categorical crossentropy loss metric, which determines how to adjust the weights within the model. model . compile ( loss = keras . losses . categorical_crossentropy , optimizer = keras . optimizers . Adam (), metrics = [ 'accuracy' ]) model . fit ( x_train , y_train , batch_size = batch_size , epochs = epochs , verbose = 1 , validation_data = ( x_test , y_test )) Test Model Now here is the big finish, lets see how well the model performs! We will do this by running through our test set and having the model produce a prediction. Thankfully, there is already a function built into the model for this. score = model . evaluate ( x_test , y_test , verbose = 0 ) print ( 'Test loss:' , score [ 0 ]) print ( 'Test accuracy:' , score [ 1 ]) Let's see what happens on an individual image level: to_predict = np . array ([ x_test [ 0 ]]) output = model . predict ( to_predict ) pixels = to_predict [ 0 ] . reshape (( 28 , 28 )) plt . imshow ( pixels , cmap = 'gray' ) output np . argmax ( output ) And there you have it! Congratulations on successfully creating, training, and testing your own neural network.","title":"MNIST Digit Prediction"},{"location":"advanced/mnist/#handwritten-digit-classification","text":"We will program and train a machine learning model to recognize handwritten numbers. The code for this lesson can be found here .","title":"Handwritten Digit Classification"},{"location":"advanced/mnist/#but-what-is-machine-learnig","text":"Process of determining the function that gives a plausible result y for a set of inputs, in form of a vector x . In its simplest form, this could be linear regression, where we find the line of best fit through the data. In more complex forms, however, this can be training a neural network to fit very non-linear data. We will use a type of neural network to recognize our handwritten numbers.","title":"But What Is Machine Learnig?"},{"location":"advanced/mnist/#types-of-neural-networks","text":"As you can see, there are many different types, or architectures of neural networks. Some of the most common are Feed Forward, Recurrent, LSTM, and AutoEncoder neural networks. The other most common is the one that we will use, or a Convolutional Neural Network.","title":"Types of Neural Networks"},{"location":"advanced/mnist/#convolutional-neural-network","text":"Since we have image data, we will use a Convolutional Neural Network (CNN). A CNN works by sliding \"windows\" over the input image and aggregating nearby pixels together.","title":"Convolutional Neural Network"},{"location":"advanced/mnist/#importing-packages","text":"For this project, we will be using a machine learning package called Keras. This makes it really easy to construct our neural network. We also import matplotlib to visualize our data, and numpy for some utilities. import keras from keras.datasets import mnist # Get dataset from keras.models import Sequential from keras.layers import Dense , Dropout , Flatten # Need these types of layers from keras.layers import Conv2D , MaxPooling2D # Need convolutional layers import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np","title":"Importing Packages"},{"location":"advanced/mnist/#loading-data","text":"Important to load both a training and testing set to make sure the CNN is not \"memorizing\" the set of images it will train on. This would lead to awful accuracy in the \"real world\" # input image dimensions (pixels) img_rows , img_cols = 28 , 28 # the data, split between train and test sets ( x_train , y_train ), ( x_test , y_test ) = mnist . load_data () # manipulate the data for the CNN x_train = x_train . reshape ( x_train . shape [ 0 ], img_rows , img_cols , 1 ) x_test = x_test . reshape ( x_test . shape [ 0 ], img_rows , img_cols , 1 ) input_shape = ( img_rows , img_cols , 1 )","title":"Loading Data"},{"location":"advanced/mnist/#preprocessing-data","text":"We want to have our CNN work with numbers between 0 and 1. Since pixel values are from 0-255, we divide all numbers by 255 in order to make them between 0 and 1. We then can see how many training and testing samples we have. x_train = x_train . astype ( 'float32' ) x_test = x_test . astype ( 'float32' ) x_train /= 255 x_test /= 255 print ( 'x_train shape:' , x_train . shape ) print ( x_train . shape [ 0 ], 'train samples' ) print ( x_test . shape [ 0 ], 'test samples' )","title":"Preprocessing Data"},{"location":"advanced/mnist/#look-at-data","text":"In the next few cells, we will look at an example of a digit and see what number it is in the training set. x_train [ 0 ] pixels = x_train [ 0 ] . reshape (( 28 , 28 )) plt . imshow ( pixels , cmap = 'gray' ) print ( y_train [ 0 ])","title":"Look At Data"},{"location":"advanced/mnist/#desired-output","text":"We want to convert the desired output from a number n to a vector where the nth element is 1 and the rest are 0. Example: n = 5 Resulting Vector = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0} num_classes = 10 y_train = keras . utils . to_categorical ( y_train , num_classes ) y_test = keras . utils . to_categorical ( y_test , num_classes )","title":"Desired Output"},{"location":"advanced/mnist/#define-model","text":"Now here is the fun part. Building the model! We will have a 5 layer neural network. Feel free to play around with some of the parameters and see what works better or worse! model = Sequential () model . add ( Conv2D ( 32 , kernel_size = ( 3 , 3 ), activation = 'relu' , input_shape = input_shape )) model . add ( Conv2D ( 64 , ( 3 , 3 ), activation = 'relu' )) model . add ( MaxPooling2D ( pool_size = ( 2 , 2 ))) model . add ( Dropout ( 0.25 )) # Prevent overfitting model . add ( Flatten ()) model . add ( Dense ( 128 , activation = 'relu' )) model . add ( Dropout ( 0.5 )) model . add ( Dense ( num_classes , activation = 'softmax' )) model . summary ()","title":"Define Model"},{"location":"advanced/mnist/#set-parameters","text":"Here, we will set two parameters for the network. The first is batch size, which determines how many training examples we will look at before changing the weights in the model. We will also set the number of epochs, or iterations through the entire training set. batch_size = 128 # How many training examples will we look at before updating the weights in the matrix epochs = 12 # How many times we will run through the complete training set","title":"Set Parameters"},{"location":"advanced/mnist/#compile-and-train-model","text":"Here, we compile the model and then train it. A couple things to note. We are using the Adam optimizer, as compared to others such as stochastic gradient descent. We are measuring the success of the model through the categorical crossentropy loss metric, which determines how to adjust the weights within the model. model . compile ( loss = keras . losses . categorical_crossentropy , optimizer = keras . optimizers . Adam (), metrics = [ 'accuracy' ]) model . fit ( x_train , y_train , batch_size = batch_size , epochs = epochs , verbose = 1 , validation_data = ( x_test , y_test ))","title":"Compile and Train Model"},{"location":"advanced/mnist/#test-model","text":"Now here is the big finish, lets see how well the model performs! We will do this by running through our test set and having the model produce a prediction. Thankfully, there is already a function built into the model for this. score = model . evaluate ( x_test , y_test , verbose = 0 ) print ( 'Test loss:' , score [ 0 ]) print ( 'Test accuracy:' , score [ 1 ]) Let's see what happens on an individual image level: to_predict = np . array ([ x_test [ 0 ]]) output = model . predict ( to_predict ) pixels = to_predict [ 0 ] . reshape (( 28 , 28 )) plt . imshow ( pixels , cmap = 'gray' ) output np . argmax ( output ) And there you have it! Congratulations on successfully creating, training, and testing your own neural network.","title":"Test Model"},{"location":"advanced/stocks/","text":"Stock Analysis and (Virtual) Trading With Python Disclaimer - This is NOT Financial advice Checkout the notebook here .","title":"Stock Ticker Analysis"},{"location":"advanced/stocks/#stock-analysis-and-virtual-trading-with-python","text":"Disclaimer - This is NOT Financial advice Checkout the notebook here .","title":"Stock Analysis and (Virtual) Trading With Python"},{"location":"intermediate/01-variables-scope/","text":"Variables If you've made it this far, you know a variable is a container for data in Python. Let's dive a little deeper into the world of variables! Naming conventions In the Python community , the general accepted format for variable and function names is all lower case, with multiple words separated by underscores. For example: variable = 0 my_variable = 0 my_function_name() Giving variables and functions meaningful names Variable names should be meaningful to you as the programmer, to any other developers that may be collaborating with you and any developers that may look at your code in the future. Below are two instances of the same code using different variable and function names. Which is easier to read? def my_first_function ( arg ): variable1 = arg + 2 return variable1 def my_second_function ( arg ): variable = arg * 5 return variable print ( my_first_function ( my_second_function ( 5 ))) def plus_two ( num ): two_more = num + 2 return two_more def times_five ( num ): five_times = num * 5 return five_times print ( plus_two ( times_five ( 5 ))) Variable Scope A variable's scope refers to where in your code you can access that variable. The scope of a variable defined within a function is limited to the function in which it is defined. This is an example of a local variable. For example, using the more legible code above: def plus_two ( num ): two_more = num + 2 return two_more def times_five ( num ): five_times = num * 5 return five_times print ( plus_two ( times_five ( 5 ))) print ( five_times ) Attempting to print the value of five_times within the global scope of the code will result in a NameError, because the scope of the variable five_times is limited to the times_five function. Conversely, a global variable is a variable that can be accessed anywhere within your code. Global variables are usually created within the main body of your code, that is outside of functions, as demonstrated below. You can see the my_name variable is accessible within the who_is_awesome function. my_name = \"Zack\" def who_is_awesome (): print ( my_name + \" is awesome!\" ) You can make a variable used within a function globally accessible by using the 'global' keyword. For example, def who_is_awesome ( name ): global awesome_statement awesome_statement = name + \" is awesome!\" print ( \"Variable Reference Within Function: \" + awesome_statement ) who_is_awesome ( \"Zack\" ) print ( \"Global Variable Use: \" + awesome_statement ) Food for Thought When would it make sense to use the global keyword within a function to make a variable globally accessible, instead of returning the variable from the function?","title":"Variables and Scope"},{"location":"intermediate/01-variables-scope/#variables","text":"If you've made it this far, you know a variable is a container for data in Python. Let's dive a little deeper into the world of variables!","title":"Variables"},{"location":"intermediate/01-variables-scope/#naming-conventions","text":"In the Python community , the general accepted format for variable and function names is all lower case, with multiple words separated by underscores. For example: variable = 0 my_variable = 0 my_function_name()","title":"Naming conventions"},{"location":"intermediate/01-variables-scope/#giving-variables-and-functions-meaningful-names","text":"Variable names should be meaningful to you as the programmer, to any other developers that may be collaborating with you and any developers that may look at your code in the future. Below are two instances of the same code using different variable and function names. Which is easier to read? def my_first_function ( arg ): variable1 = arg + 2 return variable1 def my_second_function ( arg ): variable = arg * 5 return variable print ( my_first_function ( my_second_function ( 5 ))) def plus_two ( num ): two_more = num + 2 return two_more def times_five ( num ): five_times = num * 5 return five_times print ( plus_two ( times_five ( 5 )))","title":"Giving variables and functions meaningful names"},{"location":"intermediate/01-variables-scope/#variable-scope","text":"A variable's scope refers to where in your code you can access that variable. The scope of a variable defined within a function is limited to the function in which it is defined. This is an example of a local variable. For example, using the more legible code above: def plus_two ( num ): two_more = num + 2 return two_more def times_five ( num ): five_times = num * 5 return five_times print ( plus_two ( times_five ( 5 ))) print ( five_times ) Attempting to print the value of five_times within the global scope of the code will result in a NameError, because the scope of the variable five_times is limited to the times_five function. Conversely, a global variable is a variable that can be accessed anywhere within your code. Global variables are usually created within the main body of your code, that is outside of functions, as demonstrated below. You can see the my_name variable is accessible within the who_is_awesome function. my_name = \"Zack\" def who_is_awesome (): print ( my_name + \" is awesome!\" ) You can make a variable used within a function globally accessible by using the 'global' keyword. For example, def who_is_awesome ( name ): global awesome_statement awesome_statement = name + \" is awesome!\" print ( \"Variable Reference Within Function: \" + awesome_statement ) who_is_awesome ( \"Zack\" ) print ( \"Global Variable Use: \" + awesome_statement )","title":"Variable Scope"},{"location":"intermediate/01-variables-scope/#food-for-thought","text":"When would it make sense to use the global keyword within a function to make a variable globally accessible, instead of returning the variable from the function?","title":"Food for Thought"},{"location":"intermediate/02-data-types/","text":"Data Types So we know that data is a piece of information, but there are of course different types of data! Let's illustrate the importance of data types... three_string = \"3\" three_integer = 3 print ( three_string * 3 ) print ( three_integer * 3 ) Notice the difference in the output when multiplying three_string and three_int by three. three_string * 3 returned 333, whereas three_integer * 3 returned 9. This is because the three_string variable is a string datatype. What are the different data types Text string: str example: my_string = \"this is a string\" Numeric integer: int example: my_int = 3 float: float example: my_float = 3.14 Both integers and floats can be negative. For example: my_negative_int = -3 Sequence List: list \u2014 an unordered list of data / objects. example: my_list = [1, 2, my_float, 4, \"Bananas\"] Tuple: tuple \u2014 an ordered and immutable list of of data / objects. Immutable means unchangeable , once you have defined a tuple you cannot change, remove or reorder elements\u2014 for any of these operations, use a list. example: my_tuple = (1, 2, my_float, 4, \"Bananas\") As you can see, elements in lists and tuples do not have to be the same data type. There are three integers, a variable and a string in both the list and tuple shown above. Boolean Boolean: bool \u2014 a binary data type that is either True or False example: my_bool = True None -None: NoneType \u2014 None is a keyword in Python used to indicate a null value. None differs from False or an empty string ( \"\" ). A function that does not specify a return value will always return None. def no_return (): print ( \"This function does not return anything.\" ) no_return_response = no_return () print ( no_return_response == None ) print ( type ( no_return_response )) As you can see from the code above, when we assign the result of the no_return() function call to the no_return_response variable, the print statement in the function is executed. However, the value of no_return_response is None, since there was no return statement in the no_return function. Mapping -Dictionary: dict \u2014 an unordered data type consisting of key, value pairs Creating a dictionary A dictionary is demarcated by curly braces around key:value pairs that are separated by commas. Keys and values do not need to be the same data types. python my_dict = {\"dictionary\" : \"a book or electronic resource that lists the words of a language\", \"int\" : \"short for integer. A whole number; a number that is not a fraction\", \"float\" : \"for our purposes this means a decimal number\u2014 a number that consists of a whole number and a fractional part\", \"bool\" : \"short for boolean; a binary, True or False value\"} We'll learn more about dictionaries in the maps section Type Casting Strings consisting of digits can easily be converted to floats or integers #ask the user to input a number number = input ( \"Type a number here and press 'enter' to proceed>>>\" ) #side note: '\\n' tells python to print a newline #side note: we can use the the type keyword to determine what datatype a variable is print ( \" \\n the number variable is currently the \" + str ( type ( number )) + \" data type \\n \" ) #as you can see the number the user entered belongs to the str data type, that's because input always returns a string. #so if we wanted to see what two times the number the user entered is how would we do it? print ( number * 2 ) #that didn't do what we wanted, did it? #let's convert the number variable to the int data type: number_as_int = int ( number ) print ( \" \\n the number_as_int variable is currently the \" + str ( type ( number_as_int )) + \" data type\" ) #okay now our number is an int! #as you know, division operation always returns a float, even if there is no remainder my_float = 8 / 4 print ( \" \\n my_float is \" + str ( my_float )) You Try It! We know what type casting is and how to convert a string to an integer. We also know that a division operation in Python will always return a float, regardless of whether or not there's a remainder. Finally, we know using the modulo operator ( % ) in place of the division operator will return only the remainder\u2014for example, 7 % 4 will return 3. Using these pieces of knowledge, implement a function that will convert a float to an int, but only if there is no remainder. Complete the function definition for float_converter below! We've put some test conditions below to check your function. def float_converter ( some_float ): #if some_float has a remainder return the original float #else return the some_float as an int #test our function: expecting_float = float_converter ( 7 / 3 ) expecting_int = float_converter ( 4 / 2 ) test1 = expecting_float == 7 / 3 test2 = expecting_int == 2 and type ( expecting_int ) == int test3 = expecting_float != 2 if test1 and test2 : print ( \"Congrats! You've properly implemented the float_converter function!\" ) elif test1 : print ( \"It looks like you've properly returned the original float, but didn't return some_float as an integer when there's no remainder.\" ) elif test2 and test3 : print ( \"It looks like you've properly type returned some_float as an integer when there's no remainder! But you still need to return the original float when there is a remainder.\" ) elif test2 and not test3 : print ( \"It looks It looks like you may always be returning my_float as an integer regardless of whether or not there's a remainder.\" ) else : print ( \"It looks like you haven't properly implemented either of the requirements for float_converter.\" ) Food for Thought When learning about the dictionary data type, we created my_dict , which contained data types and their definitions. Let's say in addition to the definitions of each data type, I wanted to add part of speech and store an example of each data type. How might we do this? Hint: it involves more dictionaries!","title":"Data Types"},{"location":"intermediate/02-data-types/#data-types","text":"So we know that data is a piece of information, but there are of course different types of data! Let's illustrate the importance of data types... three_string = \"3\" three_integer = 3 print ( three_string * 3 ) print ( three_integer * 3 ) Notice the difference in the output when multiplying three_string and three_int by three. three_string * 3 returned 333, whereas three_integer * 3 returned 9. This is because the three_string variable is a string datatype.","title":"Data Types"},{"location":"intermediate/02-data-types/#what-are-the-different-data-types","text":"Text string: str example: my_string = \"this is a string\" Numeric integer: int example: my_int = 3 float: float example: my_float = 3.14 Both integers and floats can be negative. For example: my_negative_int = -3 Sequence List: list \u2014 an unordered list of data / objects. example: my_list = [1, 2, my_float, 4, \"Bananas\"] Tuple: tuple \u2014 an ordered and immutable list of of data / objects. Immutable means unchangeable , once you have defined a tuple you cannot change, remove or reorder elements\u2014 for any of these operations, use a list. example: my_tuple = (1, 2, my_float, 4, \"Bananas\") As you can see, elements in lists and tuples do not have to be the same data type. There are three integers, a variable and a string in both the list and tuple shown above. Boolean Boolean: bool \u2014 a binary data type that is either True or False example: my_bool = True None -None: NoneType \u2014 None is a keyword in Python used to indicate a null value. None differs from False or an empty string ( \"\" ). A function that does not specify a return value will always return None. def no_return (): print ( \"This function does not return anything.\" ) no_return_response = no_return () print ( no_return_response == None ) print ( type ( no_return_response )) As you can see from the code above, when we assign the result of the no_return() function call to the no_return_response variable, the print statement in the function is executed. However, the value of no_return_response is None, since there was no return statement in the no_return function. Mapping -Dictionary: dict \u2014 an unordered data type consisting of key, value pairs Creating a dictionary A dictionary is demarcated by curly braces around key:value pairs that are separated by commas. Keys and values do not need to be the same data types. python my_dict = {\"dictionary\" : \"a book or electronic resource that lists the words of a language\", \"int\" : \"short for integer. A whole number; a number that is not a fraction\", \"float\" : \"for our purposes this means a decimal number\u2014 a number that consists of a whole number and a fractional part\", \"bool\" : \"short for boolean; a binary, True or False value\"} We'll learn more about dictionaries in the maps section","title":"What are the different data types"},{"location":"intermediate/02-data-types/#type-casting","text":"Strings consisting of digits can easily be converted to floats or integers #ask the user to input a number number = input ( \"Type a number here and press 'enter' to proceed>>>\" ) #side note: '\\n' tells python to print a newline #side note: we can use the the type keyword to determine what datatype a variable is print ( \" \\n the number variable is currently the \" + str ( type ( number )) + \" data type \\n \" ) #as you can see the number the user entered belongs to the str data type, that's because input always returns a string. #so if we wanted to see what two times the number the user entered is how would we do it? print ( number * 2 ) #that didn't do what we wanted, did it? #let's convert the number variable to the int data type: number_as_int = int ( number ) print ( \" \\n the number_as_int variable is currently the \" + str ( type ( number_as_int )) + \" data type\" ) #okay now our number is an int! #as you know, division operation always returns a float, even if there is no remainder my_float = 8 / 4 print ( \" \\n my_float is \" + str ( my_float ))","title":"Type Casting"},{"location":"intermediate/02-data-types/#you-try-it","text":"We know what type casting is and how to convert a string to an integer. We also know that a division operation in Python will always return a float, regardless of whether or not there's a remainder. Finally, we know using the modulo operator ( % ) in place of the division operator will return only the remainder\u2014for example, 7 % 4 will return 3. Using these pieces of knowledge, implement a function that will convert a float to an int, but only if there is no remainder. Complete the function definition for float_converter below! We've put some test conditions below to check your function. def float_converter ( some_float ): #if some_float has a remainder return the original float #else return the some_float as an int #test our function: expecting_float = float_converter ( 7 / 3 ) expecting_int = float_converter ( 4 / 2 ) test1 = expecting_float == 7 / 3 test2 = expecting_int == 2 and type ( expecting_int ) == int test3 = expecting_float != 2 if test1 and test2 : print ( \"Congrats! You've properly implemented the float_converter function!\" ) elif test1 : print ( \"It looks like you've properly returned the original float, but didn't return some_float as an integer when there's no remainder.\" ) elif test2 and test3 : print ( \"It looks like you've properly type returned some_float as an integer when there's no remainder! But you still need to return the original float when there is a remainder.\" ) elif test2 and not test3 : print ( \"It looks It looks like you may always be returning my_float as an integer regardless of whether or not there's a remainder.\" ) else : print ( \"It looks like you haven't properly implemented either of the requirements for float_converter.\" )","title":"You Try It!"},{"location":"intermediate/02-data-types/#food-for-thought","text":"When learning about the dictionary data type, we created my_dict , which contained data types and their definitions. Let's say in addition to the definitions of each data type, I wanted to add part of speech and store an example of each data type. How might we do this? Hint: it involves more dictionaries!","title":"Food for Thought"},{"location":"intermediate/03-data-type-validation/","text":"Checking Data Types of Function Parameters In the beginning course we learned how to pass arguments to functions. Now we learn how to make sure our functions get the data that they expect! We saw in the data types lab we can use the type keyword to get the type of a variable (e.g. type(my_var) ). We can use this in combination with the is equal to operator ( == ) to make sure a variable passed to a function is the right data type. def validateType ( expecting_string ): if type ( expecting_string ) == str : print ( \"You passed a string!\" ) else : print ( \"You passed something that wasn't a string!\" ) As you may recall, during the data type labs we used the input function to solicit user input. The response from input is always a string! So if we ask the user to input a number, how do we confirm the input is in fact a number before type casting int on the user input? Remember type casting int on an alphabetic string will throw an error. Let's check it out. def cast_to_int (): user_input = input ( \"Enter an int \\n >\" ) user_input_as_int = int ( user_input ) return user_input_as_int some_int = cast_to_int () print ( some_int ) Let's try running this on trinket.io and when asked to enter an int, let's enter a word! As you can see we get a type error, because we're trying to convert an alphabetic string to an integer: ValueError : invalid literal for int So what's the work around? Strings have some very useful methods (methods are functions that belong to objects. We'll take about objects in the advanced section), among them .isdigit() ! Let's see it in action! def cast_to_int (): user_input = input ( \"Enter an int \\n >\" ) if user_input . isdigit (): user_input_as_int = int ( user_input ) return user_input_as_int else : return \"You did not input an integer!\" some_int = cast_to_int () print ( some_int ) Let's say the user input was critical to the program we're building and if the user does not input an integer we want to throw an error to the user. We can use the assert keyword to achieve this. The syntax for the assert keyword is as follows: assert some_conditional_statement, \"Error message to output.\" Let's see it in action below! def cast_to_int (): user_input = input ( \"Enter an int \\n >\" ) assert user_input . isdigit (), \"You did not input an integer!\" user_input_as_int = int ( user_input ) return user_input_as_int some_int = cast_to_int () print ( some_int ) You try it! Let's say we want to continously bug a user until they input an integer. How might we achieve this using the lesson above + what we know about while loops?","title":"Data Types & Function Parameters"},{"location":"intermediate/03-data-type-validation/#checking-data-types-of-function-parameters","text":"In the beginning course we learned how to pass arguments to functions. Now we learn how to make sure our functions get the data that they expect! We saw in the data types lab we can use the type keyword to get the type of a variable (e.g. type(my_var) ). We can use this in combination with the is equal to operator ( == ) to make sure a variable passed to a function is the right data type. def validateType ( expecting_string ): if type ( expecting_string ) == str : print ( \"You passed a string!\" ) else : print ( \"You passed something that wasn't a string!\" ) As you may recall, during the data type labs we used the input function to solicit user input. The response from input is always a string! So if we ask the user to input a number, how do we confirm the input is in fact a number before type casting int on the user input? Remember type casting int on an alphabetic string will throw an error. Let's check it out. def cast_to_int (): user_input = input ( \"Enter an int \\n >\" ) user_input_as_int = int ( user_input ) return user_input_as_int some_int = cast_to_int () print ( some_int ) Let's try running this on trinket.io and when asked to enter an int, let's enter a word! As you can see we get a type error, because we're trying to convert an alphabetic string to an integer: ValueError : invalid literal for int So what's the work around? Strings have some very useful methods (methods are functions that belong to objects. We'll take about objects in the advanced section), among them .isdigit() ! Let's see it in action! def cast_to_int (): user_input = input ( \"Enter an int \\n >\" ) if user_input . isdigit (): user_input_as_int = int ( user_input ) return user_input_as_int else : return \"You did not input an integer!\" some_int = cast_to_int () print ( some_int ) Let's say the user input was critical to the program we're building and if the user does not input an integer we want to throw an error to the user. We can use the assert keyword to achieve this. The syntax for the assert keyword is as follows: assert some_conditional_statement, \"Error message to output.\" Let's see it in action below! def cast_to_int (): user_input = input ( \"Enter an int \\n >\" ) assert user_input . isdigit (), \"You did not input an integer!\" user_input_as_int = int ( user_input ) return user_input_as_int some_int = cast_to_int () print ( some_int )","title":"Checking Data Types of Function Parameters"},{"location":"intermediate/03-data-type-validation/#you-try-it","text":"Let's say we want to continously bug a user until they input an integer. How might we achieve this using the lesson above + what we know about while loops?","title":"You try it!"},{"location":"intermediate/04-maps/","text":"Maps in Python -Dictionary: dict \u2014 an unordered data type consisting of key, value pairs Creating a dictionary A dictionary is demarcated by curly braces around key:value pairs that are separated by commas. my_dict = { \"dictionary\" : \"a book or electronic resource that lists the words of a language\" , \"int\" : \"short for integer. A whole number; a number that is not a fraction\" , \"float\" : \"for our purposes this means a decimal number\u2014 a number that consists of a whole number and a fractional part\" , \"bool\" : \"short for boolean; a binary, True or False value\" } Retrieving the value of a key from a dictionary: remember a dictionary consists of key, value pairs. To get a value for a given key we reference the key: print ( my_dict [ 'integer' ]) If we try to reference a key that does not exist in a dictionary a KeyError will be thrown. print ( my_dict [ 'tuple' ]) A quick way to avoid the KeyError is by using the .get() method for dictionaries: print ( my_dict . get ( 'tuple' )) # this will print None because the key 'tuple' does not exist in my_dict. Another way to avoid the KeyError and determine if a key exists in a dictionary is to use the in keyword. if 'tuple' in my_dict : print ( \"'tuple' is a key in my_dict\" ) else : print ( \"'tuple' is NOT a key in my_dict\" ) if 'int' in my_dict : print ( \"'int' is a key in my_dict\" ) else : print ( \"'int' is NOT a key in my_dict\" ) Adding or updating a key / value pair to a dictionary: my_dict [ 'str' ] = \"short for string; a text data type in Python defined using a pair of double or single quotes around the data\" You try it! Using your knowledge of how dictionaries and conditional statements work, create a function that takes a key and a value as arguments and will either add the key/value pair and print \"This key / value pair has been added to the dictionary\" if the key does not exist in the dictionary, or prints \"This key is already in the dictionary!\" if the key already exists. Also important to keep in mind when doing this is what we just learned about variable scopes! my_dict = { \"dictionary\" : \"a book or electronic resource that lists the words of a language\" , \"int\" : \"short for integer. A whole number; a number that is not a fraction\" , \"float\" : \"for our purposes this means a decimal number\u2014 a number that consists of a whole number and a fractional part\" , \"bool\" : \"short for boolean; a binary, True or False value\" } def add_to_dict ( key , value ): # Implement the function here ! add_to_dict ( \"int\" , \"an integer\" ) # This should print \"This key is already in the dictionary!\" add_to_dict ( \"tuple\" , \"an ordered, immutable list of data / objects\" ) # This should add the key / value pair to the my_dict dictionary and print \"This key / value pair has been added to the dictionary\"","title":"Maps"},{"location":"intermediate/04-maps/#maps-in-python","text":"-Dictionary: dict \u2014 an unordered data type consisting of key, value pairs Creating a dictionary A dictionary is demarcated by curly braces around key:value pairs that are separated by commas. my_dict = { \"dictionary\" : \"a book or electronic resource that lists the words of a language\" , \"int\" : \"short for integer. A whole number; a number that is not a fraction\" , \"float\" : \"for our purposes this means a decimal number\u2014 a number that consists of a whole number and a fractional part\" , \"bool\" : \"short for boolean; a binary, True or False value\" } Retrieving the value of a key from a dictionary: remember a dictionary consists of key, value pairs. To get a value for a given key we reference the key: print ( my_dict [ 'integer' ]) If we try to reference a key that does not exist in a dictionary a KeyError will be thrown. print ( my_dict [ 'tuple' ]) A quick way to avoid the KeyError is by using the .get() method for dictionaries: print ( my_dict . get ( 'tuple' )) # this will print None because the key 'tuple' does not exist in my_dict. Another way to avoid the KeyError and determine if a key exists in a dictionary is to use the in keyword. if 'tuple' in my_dict : print ( \"'tuple' is a key in my_dict\" ) else : print ( \"'tuple' is NOT a key in my_dict\" ) if 'int' in my_dict : print ( \"'int' is a key in my_dict\" ) else : print ( \"'int' is NOT a key in my_dict\" ) Adding or updating a key / value pair to a dictionary: my_dict [ 'str' ] = \"short for string; a text data type in Python defined using a pair of double or single quotes around the data\"","title":"Maps in Python"},{"location":"intermediate/04-maps/#you-try-it","text":"Using your knowledge of how dictionaries and conditional statements work, create a function that takes a key and a value as arguments and will either add the key/value pair and print \"This key / value pair has been added to the dictionary\" if the key does not exist in the dictionary, or prints \"This key is already in the dictionary!\" if the key already exists. Also important to keep in mind when doing this is what we just learned about variable scopes! my_dict = { \"dictionary\" : \"a book or electronic resource that lists the words of a language\" , \"int\" : \"short for integer. A whole number; a number that is not a fraction\" , \"float\" : \"for our purposes this means a decimal number\u2014 a number that consists of a whole number and a fractional part\" , \"bool\" : \"short for boolean; a binary, True or False value\" } def add_to_dict ( key , value ): # Implement the function here ! add_to_dict ( \"int\" , \"an integer\" ) # This should print \"This key is already in the dictionary!\" add_to_dict ( \"tuple\" , \"an ordered, immutable list of data / objects\" ) # This should add the key / value pair to the my_dict dictionary and print \"This key / value pair has been added to the dictionary\"","title":"You try it!"},{"location":"intermediate/05-files/","text":"Reading and Writing Files in Python At this point you should now have python installed on your computer and no longer be using trinket.io. We recommend installing Anaconda and using the Spyder integrated development environment (IDE). Python makes it easy to read and write text files. The general syntax for opening a file is as follows: file = open('/file/path/filename.txt', 'mode') The first argument is the path the file on your computer. If the file you're trying to open is in the same folder as your python script you can just input the filename, if not you'll need the path to file. For example, let's say you're using a Mac, your username is Bella, and you're trying to open a file called \"myfile.txt\" in your downloads folder. The path to that file would be: /Users/Bella/Downloads/myfile.txt Valid arguments for the mode parameter are: 'w': writing to a file, this will overwrite a file if it already exists. 'a': append to a file, you can add new lines to a file that already exists, otherwise it will create the file. 'r': to read a file. Reading Files For our example we're going to download Herman Melville's Moby-Dick from the Gutenberg Project to read. f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) ### Let's take all the lines in Moby-Dick and store them in a list! lines = f . readlines () ### Close the file f . close () Calling the .readlines() method on a file is very useful. If we wanted to do this manually, we would iterate over the lines in the file and add them one by one to a list. f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) lines = [] #define empty list for line in f : lines . append ( line ) #we can use the .append() method to add new items to a list! f . close () Let's say we needed to know exactly how many times each word appears in Moby-Dick : how might we do that? We'd have to account for things like punctuation, captalization and newline characters ('\\n'). We'd also need to get every word by itself. from string import punctuation #punctuation from the string library is a string that contains all punctuation marks #you can run print(punctuation) to see what this looks like punctuation_list = list ( punctuation ) #convert string of punctuation marks to list f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) #open Moby-Dick file lines = f . readlines () #put all lines from Moby-Dick into a list f . close () #close the file clean_lines = [] #empty list for lines stripped of newline characters and all characters converted to lowercase for line in lines : #go through every line in the file clean_line = line . strip ( \" \\n \" ) #get rid of new-line characters clean_line = clean_line . lower () #convert everything to lowercase clean_lines . append ( clean_line ) #add cleaned line to clean_lines words = {} #create empty dictionary for words for line in clean_lines : #go through every line in the file for mark in punctuation_list : #go through every punctuation mark line = line . replace ( mark , \"\" ) #use replace method to replace each possible punctuation mark with an empty string line_words = line . split ( \" \" ) #we're using the string split() method to separate each line by space character #this converts the line to a list #for example: \"This is a sentence.\".split(\" \") --> ['This', 'is', 'a', 'sentence.'] for word in line_words : #iterate over every word in the line if word not in words : # if we haven't seen this word yet words [ word ] = 1 #add it to the words dictionary, and mark the count as 1 else : words [ word ] += 1 #we've already seen this word, so increment the count by 1 The method we used above to remove punctuation characters from the lines is not the most computationally efficent. We're going to learn a better way to do this in the section on Regex expressions. One thing we left out from the mapping section is that you can iterate over a dictionary using the .items() method. Here's what that looks like: my_dict = { 1 : \"one\" , 2 : \"two\" , 3 : \"three\" } for key , value in my_dict . items (): print ( key , value ) #this prints: #1 one #2 two #3 three You Try It! If you recall, a dictionary is an unordered data structure. Use what we learned about iterating over items in a dictionary to determine what word occurs the most frequently in Moby-Dick ! Writing Files Let's say we wanted to write out Moby-Dick with no capital letters. Here's how we could approach that: f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) #open Moby-Dick file lines = f . readlines () #put all lines from Moby-Dick into a list f . close () #close the file new_file = open ( \"/Users/Bella/Documents/moby-dick_lowercase.txt\" , \"w\" ) #write new file to Documents folder for line in lines : new_file . write ( line . lower ()) new_file . close ()","title":"Files"},{"location":"intermediate/05-files/#reading-and-writing-files-in-python","text":"At this point you should now have python installed on your computer and no longer be using trinket.io. We recommend installing Anaconda and using the Spyder integrated development environment (IDE). Python makes it easy to read and write text files. The general syntax for opening a file is as follows: file = open('/file/path/filename.txt', 'mode') The first argument is the path the file on your computer. If the file you're trying to open is in the same folder as your python script you can just input the filename, if not you'll need the path to file. For example, let's say you're using a Mac, your username is Bella, and you're trying to open a file called \"myfile.txt\" in your downloads folder. The path to that file would be: /Users/Bella/Downloads/myfile.txt Valid arguments for the mode parameter are: 'w': writing to a file, this will overwrite a file if it already exists. 'a': append to a file, you can add new lines to a file that already exists, otherwise it will create the file. 'r': to read a file.","title":"Reading and Writing Files in Python"},{"location":"intermediate/05-files/#reading-files","text":"For our example we're going to download Herman Melville's Moby-Dick from the Gutenberg Project to read. f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) ### Let's take all the lines in Moby-Dick and store them in a list! lines = f . readlines () ### Close the file f . close () Calling the .readlines() method on a file is very useful. If we wanted to do this manually, we would iterate over the lines in the file and add them one by one to a list. f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) lines = [] #define empty list for line in f : lines . append ( line ) #we can use the .append() method to add new items to a list! f . close () Let's say we needed to know exactly how many times each word appears in Moby-Dick : how might we do that? We'd have to account for things like punctuation, captalization and newline characters ('\\n'). We'd also need to get every word by itself. from string import punctuation #punctuation from the string library is a string that contains all punctuation marks #you can run print(punctuation) to see what this looks like punctuation_list = list ( punctuation ) #convert string of punctuation marks to list f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) #open Moby-Dick file lines = f . readlines () #put all lines from Moby-Dick into a list f . close () #close the file clean_lines = [] #empty list for lines stripped of newline characters and all characters converted to lowercase for line in lines : #go through every line in the file clean_line = line . strip ( \" \\n \" ) #get rid of new-line characters clean_line = clean_line . lower () #convert everything to lowercase clean_lines . append ( clean_line ) #add cleaned line to clean_lines words = {} #create empty dictionary for words for line in clean_lines : #go through every line in the file for mark in punctuation_list : #go through every punctuation mark line = line . replace ( mark , \"\" ) #use replace method to replace each possible punctuation mark with an empty string line_words = line . split ( \" \" ) #we're using the string split() method to separate each line by space character #this converts the line to a list #for example: \"This is a sentence.\".split(\" \") --> ['This', 'is', 'a', 'sentence.'] for word in line_words : #iterate over every word in the line if word not in words : # if we haven't seen this word yet words [ word ] = 1 #add it to the words dictionary, and mark the count as 1 else : words [ word ] += 1 #we've already seen this word, so increment the count by 1 The method we used above to remove punctuation characters from the lines is not the most computationally efficent. We're going to learn a better way to do this in the section on Regex expressions. One thing we left out from the mapping section is that you can iterate over a dictionary using the .items() method. Here's what that looks like: my_dict = { 1 : \"one\" , 2 : \"two\" , 3 : \"three\" } for key , value in my_dict . items (): print ( key , value ) #this prints: #1 one #2 two #3 three","title":"Reading Files"},{"location":"intermediate/05-files/#you-try-it","text":"If you recall, a dictionary is an unordered data structure. Use what we learned about iterating over items in a dictionary to determine what word occurs the most frequently in Moby-Dick !","title":"You Try It!"},{"location":"intermediate/05-files/#writing-files","text":"Let's say we wanted to write out Moby-Dick with no capital letters. Here's how we could approach that: f = open ( \"/Users/Bella/Downloads/moby10b.txt\" , \"r\" ) #open Moby-Dick file lines = f . readlines () #put all lines from Moby-Dick into a list f . close () #close the file new_file = open ( \"/Users/Bella/Documents/moby-dick_lowercase.txt\" , \"w\" ) #write new file to Documents folder for line in lines : new_file . write ( line . lower ()) new_file . close ()","title":"Writing Files"},{"location":"intermediate/06-images/","text":"Reading Images in Python Opening and displaying images in Python is pretty straightforward. It's a bit different than opening text files though. To open an image, let's use Python's built-in pil library. from PIL import Image my_image = Image . open ( \"/path/to/image.jpg\" ) my_image . show () The CoderDojo AI Racing League will explore more around working with image data.","title":"Images"},{"location":"intermediate/06-images/#reading-images-in-python","text":"Opening and displaying images in Python is pretty straightforward. It's a bit different than opening text files though. To open an image, let's use Python's built-in pil library. from PIL import Image my_image = Image . open ( \"/path/to/image.jpg\" ) my_image . show () The CoderDojo AI Racing League will explore more around working with image data.","title":"Reading Images in Python"},{"location":"intermediate/bfsMaze/","text":"Maze Solving with Breadth-First Search In this lab, we are going to solve a maze with an algorithm called breadth-first search . Before we do though, we need to get some terminology out of the way. There are two main ways that we will be storing data, known as data structures . These are: A graph is a data structure representing data that is interconnected. We will be representing our maze this way. Graphs are made of of nodes and edges . Think of edges as roads that connect different nodes together. In this maze, we will hopping from node to node via these edges. A queue is another commonly used data structure. Think of it as a line that we always take from the front of and always add to the back (no budging). First, download the code template found in the src/intermediate folder of the repository, found here . Then, lets try and implement a solution to solve it! One solution is breadth-first search, or BFS. BFS works by cycling through all possible nodes one hop away from your current position, adding them to a queue and then cycling through all of those nodes in the queue to see if they are the solution. Lets see how it is implemented below: #Takes as input a Square object node in a graph of Square nodes. # This will always be the Square node representing (0,0), the start position #Performs BFS until the goal Square is found (the Square with color = \"blue\"). #Returns a list containing each Square node in the path from the start # (0,0) to the goal node, inclusive, in order from start to goal. def find_path ( start_node ): start_node . set_color ( \"gray\" ) start_node . prev = None q = [] # Our queue of nodes visited q . append ( start_node ) # Add starting node to the end of the queue while len ( q ) != 0 : # Runs when there are still nodes in the queue start_node = q . pop ( 0 ) # Remove the node in the front of the queue for node in start_node . adj : # Look at every item in the current node's adjacency list if node . get_color () == \"white\" : # If the color is white, we haven't visited this node before node . set_color ( \"grey\" ) node . depth = start_node . depth + 1 node . prev = start_node q . append ( node ) # Add this new node to the queue elif node . get_color () == \"blue\" : # If the color is blue, we have reached our goal node . prev = start_node visited = [ node ] cur = node . prev while cur != None : # Backtrack our path, adding nodes to the visited list as we go visited . insert ( 0 , cur ) cur = cur . prev return visited start_node . set_color ( \"black\" ) There are other ways to find paths in mazes, one of which we will explore in the next lab! This lab was heavily inspired by Nathan Taylor's University of Minnesota CSCI 4041 assignment.","title":"Maze Solving with BFS"},{"location":"intermediate/bfsMaze/#maze-solving-with-breadth-first-search","text":"In this lab, we are going to solve a maze with an algorithm called breadth-first search . Before we do though, we need to get some terminology out of the way. There are two main ways that we will be storing data, known as data structures . These are: A graph is a data structure representing data that is interconnected. We will be representing our maze this way. Graphs are made of of nodes and edges . Think of edges as roads that connect different nodes together. In this maze, we will hopping from node to node via these edges. A queue is another commonly used data structure. Think of it as a line that we always take from the front of and always add to the back (no budging). First, download the code template found in the src/intermediate folder of the repository, found here . Then, lets try and implement a solution to solve it! One solution is breadth-first search, or BFS. BFS works by cycling through all possible nodes one hop away from your current position, adding them to a queue and then cycling through all of those nodes in the queue to see if they are the solution. Lets see how it is implemented below: #Takes as input a Square object node in a graph of Square nodes. # This will always be the Square node representing (0,0), the start position #Performs BFS until the goal Square is found (the Square with color = \"blue\"). #Returns a list containing each Square node in the path from the start # (0,0) to the goal node, inclusive, in order from start to goal. def find_path ( start_node ): start_node . set_color ( \"gray\" ) start_node . prev = None q = [] # Our queue of nodes visited q . append ( start_node ) # Add starting node to the end of the queue while len ( q ) != 0 : # Runs when there are still nodes in the queue start_node = q . pop ( 0 ) # Remove the node in the front of the queue for node in start_node . adj : # Look at every item in the current node's adjacency list if node . get_color () == \"white\" : # If the color is white, we haven't visited this node before node . set_color ( \"grey\" ) node . depth = start_node . depth + 1 node . prev = start_node q . append ( node ) # Add this new node to the queue elif node . get_color () == \"blue\" : # If the color is blue, we have reached our goal node . prev = start_node visited = [ node ] cur = node . prev while cur != None : # Backtrack our path, adding nodes to the visited list as we go visited . insert ( 0 , cur ) cur = cur . prev return visited start_node . set_color ( \"black\" ) There are other ways to find paths in mazes, one of which we will explore in the next lab! This lab was heavily inspired by Nathan Taylor's University of Minnesota CSCI 4041 assignment.","title":"Maze Solving with Breadth-First Search"},{"location":"intermediate/debugging/","text":"Debugging in Python","title":"Debugging"},{"location":"intermediate/debugging/#debugging-in-python","text":"","title":"Debugging in Python"},{"location":"intermediate/dfsMaze/","text":"def visit ( u ): u . set_color ( \"gray\" ) for vert in u . adj : if vert . get_color () == \"white\" : vert . prev = u path = visit ( vert ) if path != None : return path elif vert . get_color () == \"blue\" : vert . prev = u return vert u . set_color ( \"black\" ) def find_path ( start_node ): start_node . set_color ( \"gray\" ) start_node . prev = None goal = visit ( start_node ) visited = [] cur = goal while cur != None : visited . insert ( 0 , cur ) cur = cur . prev return visited #Placeholder return to avoid errors This lab was heavily inspired by Nathan Taylor's University of Minnesota CSCI 4041 assignment.","title":"Maze Solving with DFS"},{"location":"intermediate/dir/","text":"The dir() function","title":"Dir"},{"location":"intermediate/dir/#the-dir-function","text":"","title":"The dir() function"},{"location":"intermediate/intro/","text":"Introduction to Intermediate Python This course assumes you are familiar with beginning concepts in Python such as variables, loops, conditionals, random numbers, functions, function parameters, lists and basic recursion. Note that you can do the first four lessons using web-based Python programming tools like Trinket.io or repl.it. Starting with lesson #5 on Files you will need to have Python installed on your local computer. Please visit the Python.org web site for the installation instructions on your operating systems. You can use the command-line version of Python from a Terminal or shell or you can install one of the Python Integrated Development Environments (IDEs). The concepts in this course include: Variables and Scope - In this lab we learn that you can control what parts of your program can access a variable. This comes in handy when we write larger programs. Data types - This lab give you a tour of some of the data types in Python other than boring strings and integers. Checking Data Types of Function Parameters - in the beginning course we learned how to pass parameters to functions. Now we learn how to make sure our functions get the data that they expect! Maps - Maps or dictionaries are sets of key-value pairs that are crazy flexible. Unlike a list, where the index can only be fixed sequence of integers starting with 0, the keys in a map can be any integer or string in any order. Files - In this lesson we will learn how to open a file and read the data into our program with just a few lines. Not only can we read in data, but we can also write out data! So much power in a few lines of code! Images - In our CoderDojo AI Racing League we will be learning how to make a car drive autonomously. But first we need to be able to read in images and display them. In this lab we will show you how easy this is! Defining Your Own Modules - In the Beginning Python class we learned how to create functions. Now we learn how to package them up so they are easy for others to use. dir() function - If you ever want to know what functions you can throw at something we got this secret tool called \"dir\". It really takes the mystery out of what functions you can use and avoids trying to guess what function names are used. Not that guessing games aren't fun! Regular expressions - You sometimes want a list of all the files in a folder that have a .jpg extension for images. This lesson will show you how we can use a shorthand notation to make it easy to specify what files to include and which ones to skip. Debugging - When we have a hard time understanding what our programs are doing we need to be able to peak in and see the results of small steps of our programs. This lesson will show you how to squash those little \"bugs\" or errors in our code. (not real bugs, that would be mean!)","title":"Introduction to Intermediate Python"},{"location":"intermediate/intro/#introduction-to-intermediate-python","text":"This course assumes you are familiar with beginning concepts in Python such as variables, loops, conditionals, random numbers, functions, function parameters, lists and basic recursion. Note that you can do the first four lessons using web-based Python programming tools like Trinket.io or repl.it. Starting with lesson #5 on Files you will need to have Python installed on your local computer. Please visit the Python.org web site for the installation instructions on your operating systems. You can use the command-line version of Python from a Terminal or shell or you can install one of the Python Integrated Development Environments (IDEs). The concepts in this course include: Variables and Scope - In this lab we learn that you can control what parts of your program can access a variable. This comes in handy when we write larger programs. Data types - This lab give you a tour of some of the data types in Python other than boring strings and integers. Checking Data Types of Function Parameters - in the beginning course we learned how to pass parameters to functions. Now we learn how to make sure our functions get the data that they expect! Maps - Maps or dictionaries are sets of key-value pairs that are crazy flexible. Unlike a list, where the index can only be fixed sequence of integers starting with 0, the keys in a map can be any integer or string in any order. Files - In this lesson we will learn how to open a file and read the data into our program with just a few lines. Not only can we read in data, but we can also write out data! So much power in a few lines of code! Images - In our CoderDojo AI Racing League we will be learning how to make a car drive autonomously. But first we need to be able to read in images and display them. In this lab we will show you how easy this is! Defining Your Own Modules - In the Beginning Python class we learned how to create functions. Now we learn how to package them up so they are easy for others to use. dir() function - If you ever want to know what functions you can throw at something we got this secret tool called \"dir\". It really takes the mystery out of what functions you can use and avoids trying to guess what function names are used. Not that guessing games aren't fun! Regular expressions - You sometimes want a list of all the files in a folder that have a .jpg extension for images. This lesson will show you how we can use a shorthand notation to make it easy to specify what files to include and which ones to skip. Debugging - When we have a hard time understanding what our programs are doing we need to be able to peak in and see the results of small steps of our programs. This lesson will show you how to squash those little \"bugs\" or errors in our code. (not real bugs, that would be mean!)","title":"Introduction to Intermediate Python"},{"location":"intermediate/modules/","text":"Introduction to Intermediate Python Modules","title":"Modules"},{"location":"intermediate/modules/#introduction-to-intermediate-python","text":"","title":"Introduction to Intermediate Python"},{"location":"intermediate/modules/#modules","text":"","title":"Modules"},{"location":"intermediate/regex/","text":"Regular Expressions in Python A regular expression is a shorthand notation for describing a search pattern. Regular expressions are handy whenever you have one ore more strings and you want to detect if a specific patten of characters appears in that string. Regular expressions are mostly standardized so that if you use them other developers will quickly be able to read this the patten notation and understand the function of the pattern. Finding four digits in an input string Let's take a simple example. What if you want an input to to a function to contain four digits. The string \\d matches a single digit. Here is the python program to check to see if there are four consecutive digits in an input string: import re my_input = '1234' # check to see if there are four consecutive digits somewhere in the input digits_test = re . search ( '\\d\\d\\d\\d' , my_input ) if digits_test : print ( \"We have four digits!\" ) else : print ( \"Invalid data\" ) Run the regex-01 program on Trinket.io If you run the program as-is, it will tell you that the string '1234' will pass the test and the string We have four digits , but if you change the my_input to be 123x then the Invalid data will be returned. The name of the regular expression module is just \"re\". We must have an import this line with the \"re\" module at the start of our program. The key line has re.search() function with two parameters. The first parameter is the regular expression and the second is the string to be tested. The exact way to read this line is: check to see if there are four consecutive digits somewhere in the input Note that if you put letters or spaces before or after the four digits the test will still pass. Finding exactly four digits What if you wanted exactly four digits? For example say you have a phone system that has exactly four-digit extensions. To do this you would need to also specify two additional characters: the start expression \"^\" and the end character \"$\" . Here is what that program would look like: import re my_input = '1234' # check to for exactly four digits digits_test = re . search ( '^\\d\\d\\d\\d$' , my_input ) if digits_test : print ( \"We have exactly four digits!\" ) else : print ( \"Invalid data\" ) Run the regex-02 program on Trinket.io Checking for one or more digits Sometimes we don't know exactly how many digits an input field should contain. We might just want to say \"look for one or more digits\". We can do this by using the '+' expression which says \"look for one or more of the previous expression\". Here is a program that will check for one or more digits: import re my_input = '1' # check for one or more digits digits_test = re . search ( '^\\d+' , my_input ) if digits_test : print ( \"We have one or more digits!\" ) else : print ( \"Invalid data\" ) Common regular expression characters for validating inputs Now that you have seen several examples of regular expressions, lets list some of the most common ones we use to validate input data.: Expression Meaning Example \\d A single digit in the range 0 to 9 '\\d\\d\\d' for validating '123' ^ The start of a string '^hello' $ The end of a string 'hello'$ [a-z] Any lowercase character in the range of 'a' to 'z' '[a-z]\\d\\d' will match 'x12' [A-Z] Any uppercase character in the range 'A' to 'Z' '\\d\\d[A-Z] will match '47N' . Zero or more occurrences of the previous expression '\\d.' would match an empty string, '1' or '12' + One or more occurrences of the previous expression '\\d+' would match '1' or '12' but would not match an empty string ** ** Or \\w Characters that typically make up words. This includes upper and lowercase charcters [a-z], [A-Z] and digits as well as the underscore \\w would match 'hello_world123' Note that there is an important difference between using the \"dot\" (period) and the \"plus\" characters. We use the dot when we want to check for an optional integer. We use the plus sign when we require an integer. When we are gathering information from users in a form, we often must be careful to specify what fields should require an integer input for the field to be valid. Combining Regular Expressions: Checking E-mail Address We can combine regular expressions to make more complicated expressions. For example here are some rules that form a simple e-mail address: a string of word characters the ampersand character '@' a string of additional word characters the period character '.' some additional characters such as 'com', 'edu' Here is a regular expression that does this: re . search ( '^\\w+@\\w+\\.\\w+$' , my_input ) Recall that the \\w+ character looks for one or more word characters. Note that we had to use a backslash in from of the period so it takes it as a literal period and not as a regular expression for zero-or-more of prior expression. Here is a program that prompts the user to input a valid e-mail: import re my_input = 'a@myco.com' # check for one or more digits if re . search ( '^\\w+@\\w+\\.\\w+$' , my_input ): print ( \"E-mail address valid\" ) else : print ( \"Error: Invalid email address!\" ) Finding The Right Regular Expression You often are confronted with validating complex fields like phone numbers, zip codes, and postal addresses. The good news is that many other people have also needed to do this and with a bit of searching you can probably find a regular expression that meets your needs. One of the best places to look for regular expressions is RegExLib . You can not only search for a regular expression but you can test it on common patterns. Other users have also voted on which regular expressions are their favorites. There are also categories of regular expressions such as: E-mails Dates and times Strings Numbers URI Addresses/Phone Markup Miscellaneous From Search to The re module offers a set of functions that allows us to search a string for a match: Function Description findall Returns a list containing all matches search Returns a Match object if there is a match anywhere in the string split Returns a list where the string has been split at each match sub Replaces one or many matches with a string Python Regular Expression References Python RegEx Cheat Sheet Python Regular Expressions HOWTO","title":"Regular Expressions"},{"location":"intermediate/regex/#regular-expressions-in-python","text":"A regular expression is a shorthand notation for describing a search pattern. Regular expressions are handy whenever you have one ore more strings and you want to detect if a specific patten of characters appears in that string. Regular expressions are mostly standardized so that if you use them other developers will quickly be able to read this the patten notation and understand the function of the pattern.","title":"Regular Expressions in Python"},{"location":"intermediate/regex/#finding-four-digits-in-an-input-string","text":"Let's take a simple example. What if you want an input to to a function to contain four digits. The string \\d matches a single digit. Here is the python program to check to see if there are four consecutive digits in an input string: import re my_input = '1234' # check to see if there are four consecutive digits somewhere in the input digits_test = re . search ( '\\d\\d\\d\\d' , my_input ) if digits_test : print ( \"We have four digits!\" ) else : print ( \"Invalid data\" ) Run the regex-01 program on Trinket.io If you run the program as-is, it will tell you that the string '1234' will pass the test and the string We have four digits , but if you change the my_input to be 123x then the Invalid data will be returned. The name of the regular expression module is just \"re\". We must have an import this line with the \"re\" module at the start of our program. The key line has re.search() function with two parameters. The first parameter is the regular expression and the second is the string to be tested. The exact way to read this line is: check to see if there are four consecutive digits somewhere in the input Note that if you put letters or spaces before or after the four digits the test will still pass.","title":"Finding four digits in an input string"},{"location":"intermediate/regex/#finding-exactly-four-digits","text":"What if you wanted exactly four digits? For example say you have a phone system that has exactly four-digit extensions. To do this you would need to also specify two additional characters: the start expression \"^\" and the end character \"$\" . Here is what that program would look like: import re my_input = '1234' # check to for exactly four digits digits_test = re . search ( '^\\d\\d\\d\\d$' , my_input ) if digits_test : print ( \"We have exactly four digits!\" ) else : print ( \"Invalid data\" ) Run the regex-02 program on Trinket.io","title":"Finding exactly four digits"},{"location":"intermediate/regex/#checking-for-one-or-more-digits","text":"Sometimes we don't know exactly how many digits an input field should contain. We might just want to say \"look for one or more digits\". We can do this by using the '+' expression which says \"look for one or more of the previous expression\". Here is a program that will check for one or more digits: import re my_input = '1' # check for one or more digits digits_test = re . search ( '^\\d+' , my_input ) if digits_test : print ( \"We have one or more digits!\" ) else : print ( \"Invalid data\" )","title":"Checking for one or more digits"},{"location":"intermediate/regex/#common-regular-expression-characters-for-validating-inputs","text":"Now that you have seen several examples of regular expressions, lets list some of the most common ones we use to validate input data.: Expression Meaning Example \\d A single digit in the range 0 to 9 '\\d\\d\\d' for validating '123' ^ The start of a string '^hello' $ The end of a string 'hello'$ [a-z] Any lowercase character in the range of 'a' to 'z' '[a-z]\\d\\d' will match 'x12' [A-Z] Any uppercase character in the range 'A' to 'Z' '\\d\\d[A-Z] will match '47N' . Zero or more occurrences of the previous expression '\\d.' would match an empty string, '1' or '12' + One or more occurrences of the previous expression '\\d+' would match '1' or '12' but would not match an empty string ** ** Or \\w Characters that typically make up words. This includes upper and lowercase charcters [a-z], [A-Z] and digits as well as the underscore \\w would match 'hello_world123' Note that there is an important difference between using the \"dot\" (period) and the \"plus\" characters. We use the dot when we want to check for an optional integer. We use the plus sign when we require an integer. When we are gathering information from users in a form, we often must be careful to specify what fields should require an integer input for the field to be valid.","title":"Common regular expression characters for validating inputs"},{"location":"intermediate/regex/#combining-regular-expressions-checking-e-mail-address","text":"We can combine regular expressions to make more complicated expressions. For example here are some rules that form a simple e-mail address: a string of word characters the ampersand character '@' a string of additional word characters the period character '.' some additional characters such as 'com', 'edu' Here is a regular expression that does this: re . search ( '^\\w+@\\w+\\.\\w+$' , my_input ) Recall that the \\w+ character looks for one or more word characters. Note that we had to use a backslash in from of the period so it takes it as a literal period and not as a regular expression for zero-or-more of prior expression. Here is a program that prompts the user to input a valid e-mail: import re my_input = 'a@myco.com' # check for one or more digits if re . search ( '^\\w+@\\w+\\.\\w+$' , my_input ): print ( \"E-mail address valid\" ) else : print ( \"Error: Invalid email address!\" )","title":"Combining Regular Expressions: Checking E-mail Address"},{"location":"intermediate/regex/#finding-the-right-regular-expression","text":"You often are confronted with validating complex fields like phone numbers, zip codes, and postal addresses. The good news is that many other people have also needed to do this and with a bit of searching you can probably find a regular expression that meets your needs. One of the best places to look for regular expressions is RegExLib . You can not only search for a regular expression but you can test it on common patterns. Other users have also voted on which regular expressions are their favorites. There are also categories of regular expressions such as: E-mails Dates and times Strings Numbers URI Addresses/Phone Markup Miscellaneous","title":"Finding The Right Regular Expression"},{"location":"intermediate/regex/#from-search-to","text":"The re module offers a set of functions that allows us to search a string for a match: Function Description findall Returns a list containing all matches search Returns a Match object if there is a match anywhere in the string split Returns a list where the string has been split at each match sub Replaces one or many matches with a string","title":"From Search to"},{"location":"intermediate/regex/#python-regular-expression-references","text":"Python RegEx Cheat Sheet Python Regular Expressions HOWTO","title":"Python Regular Expression References"},{"location":"jupyter/01-inline-test-setup/","text":"Test of Jupyter Lab Inline Setup Rumor this work from ipyturtle import Turtle t = turtle . Turtle () t . clear () t . resetscreen () t . color ( 'blue' ) t . pensize ( 5 ) for i in range ( 8 ): t . fd ( 50 ) t . rt ( 45 ) t","title":"01 inline test setup"},{"location":"jupyter/01-inline-test-setup/#test-of-jupyter-lab-inline-setup","text":"Rumor this work from ipyturtle import Turtle t = turtle . Turtle () t . clear () t . resetscreen () t . color ( 'blue' ) t . pensize ( 5 ) for i in range ( 8 ): t . fd ( 50 ) t . rt ( 45 ) t","title":"Test of Jupyter Lab Inline Setup"},{"location":"jupyter/01-setup/","text":"Why Jupyter Notebook We will be running this library from within a Jupyter Notebook. Jupyter Notebooks are part of an important type in programming called Literate Programming where code and explaination of your code are interspersed in cells. Jupyter Notebooks are sometimes called the \"New Excel\" because they are both popular ways to analize data. Jupyter Notebooks are also popular with Data Scientists and Artificial Intelligence developers and has almost compleatly replaced the R Progamming programming language. We think that learning Python using Jupyter is ideal if you have some type of interactive way to see the results of your code. By combining turtle graphics with Jupyter you get the best of both worlds. Two Ways to View Turtle Graphics There are two ways to view turtle graphics in Jupyter: With the turtle being drawn in a separate window With the turtle being drawn \"inline\" directly under your code In general, inline is preferred because you can keep track of many small exercises just by scrolling down. You can also print out the notebooks to show others your work. In many of these labs we will be using a special version of the turtle library that was developed by Thomas Kluyver from the UK called the \"mobilechelonian\". We want to thank him for this work. If you want you can \"star\" the following github repository: https://github.com/takluyver/mobilechelonian Note that \"Chelonians\" are animals in the order Chelonia (or Testudines), which includes the turtles and tortoises. By picking a very distinctive name for his implementation of the turtle library Thomas avoided collision with other python libraries that had the same name. Steps Here are the steps we will go through to get turtle running in our Jupyter Notebook: Install the conda python environment systems Create a new conda environment for our turtle and activate it Use the pip tool to install the turtle library Install the Jupyter Notebooks software Start up Jupyter Notebooks Test the turtle program Install Conda Google \"install python\" on your operating system. Google \"install conda\" Create a new conda envornment: Open your terminal. Type in the following commands. conda env list conda create -n turtle python = 3 .6 conda activate turtle pip install mobilechelonian juypter notebook After you run the last command it will open a Jupyter Notbook in a web browser. You can now test that the turtle library installed correctly. from mobilechelonian import Turtle t = Turtle () t . forward ( 100 ) help ( Turtle ) References Conda Documentation","title":"Setup Turtle on Jupyter"},{"location":"jupyter/01-setup/#why-jupyter-notebook","text":"We will be running this library from within a Jupyter Notebook. Jupyter Notebooks are part of an important type in programming called Literate Programming where code and explaination of your code are interspersed in cells. Jupyter Notebooks are sometimes called the \"New Excel\" because they are both popular ways to analize data. Jupyter Notebooks are also popular with Data Scientists and Artificial Intelligence developers and has almost compleatly replaced the R Progamming programming language. We think that learning Python using Jupyter is ideal if you have some type of interactive way to see the results of your code. By combining turtle graphics with Jupyter you get the best of both worlds.","title":"Why Jupyter Notebook"},{"location":"jupyter/01-setup/#two-ways-to-view-turtle-graphics","text":"There are two ways to view turtle graphics in Jupyter: With the turtle being drawn in a separate window With the turtle being drawn \"inline\" directly under your code In general, inline is preferred because you can keep track of many small exercises just by scrolling down. You can also print out the notebooks to show others your work. In many of these labs we will be using a special version of the turtle library that was developed by Thomas Kluyver from the UK called the \"mobilechelonian\". We want to thank him for this work. If you want you can \"star\" the following github repository: https://github.com/takluyver/mobilechelonian Note that \"Chelonians\" are animals in the order Chelonia (or Testudines), which includes the turtles and tortoises. By picking a very distinctive name for his implementation of the turtle library Thomas avoided collision with other python libraries that had the same name.","title":"Two Ways to View Turtle Graphics"},{"location":"jupyter/01-setup/#steps","text":"Here are the steps we will go through to get turtle running in our Jupyter Notebook: Install the conda python environment systems Create a new conda environment for our turtle and activate it Use the pip tool to install the turtle library Install the Jupyter Notebooks software Start up Jupyter Notebooks Test the turtle program","title":"Steps"},{"location":"jupyter/01-setup/#install-conda","text":"Google \"install python\" on your operating system. Google \"install conda\"","title":"Install Conda"},{"location":"jupyter/01-setup/#create-a-new-conda-envornment","text":"Open your terminal. Type in the following commands. conda env list conda create -n turtle python = 3 .6 conda activate turtle pip install mobilechelonian juypter notebook After you run the last command it will open a Jupyter Notbook in a web browser. You can now test that the turtle library installed correctly. from mobilechelonian import Turtle t = Turtle () t . forward ( 100 ) help ( Turtle )","title":"Create a new conda envornment:"},{"location":"jupyter/01-setup/#references","text":"Conda Documentation","title":"References"},{"location":"jupyter/02-draw-figure/","text":"Draw Figure Turtle Lab in Jupyter In this lab we setup a new Jupyter notebook that will do turtle graphics. Link to Jypyter Notebook Draw Figure Jypyter Notebook","title":"Drawing Figure"},{"location":"jupyter/02-draw-figure/#draw-figure-turtle-lab-in-jupyter","text":"In this lab we setup a new Jupyter notebook that will do turtle graphics.","title":"Draw Figure Turtle Lab in Jupyter"},{"location":"jupyter/02-draw-figure/#link-to-jypyter-notebook","text":"Draw Figure Jypyter Notebook","title":"Link to Jypyter Notebook"},{"location":"jupyter/02-setup-canvas/","text":"We will be using python canvas drawing library. Unlike turtle graphics the canvas library has many powerful drawing tools. Python IPYCanvas Library Jupyter Lab We will be running this library from within a Jypyter lab. Steps Install conda Create a new conda environment Install Jupyter lab Start up Jupyter Test Canvas Setup With Conda conda env list conda create - n turtle python = 3.6 conda activate turtle juypter lab After you run the last command it will open a web browser. References Conda Documentation","title":"02 setup canvas"},{"location":"jupyter/02-setup-canvas/#jupyter-lab","text":"We will be running this library from within a Jypyter lab.","title":"Jupyter Lab"},{"location":"jupyter/02-setup-canvas/#steps","text":"Install conda Create a new conda environment Install Jupyter lab Start up Jupyter Test Canvas","title":"Steps"},{"location":"jupyter/02-setup-canvas/#setup-with-conda","text":"conda env list conda create - n turtle python = 3.6 conda activate turtle juypter lab After you run the last command it will open a web browser.","title":"Setup With Conda"},{"location":"jupyter/02-setup-canvas/#references","text":"Conda Documentation","title":"References"},{"location":"jupyter/20-canvas-color-bars/","text":"Canvas Color Bars We can draw directly into the Jupyter Lab canvas by using the Canvas drawing component. The following draws several horizontal bars of different color. from ipycanvas import Canvas canvas = Canvas ( width = 400 , height = 170 ) # draw a some lines of different colors and widths canvas . translate ( 10 , 10 ) canvas . fill_style = 'red' ; canvas . fill_rect ( 0 , 0 , 400 , 10 ) canvas . fill_style = 'orange' ; canvas . fill_rect ( 0 , 25 , 400 , 10 ) canvas . fill_style = 'yellow' ; canvas . fill_rect ( 0 , 50 , 400 , 10 ) canvas . fill_style = 'green' ; canvas . fill_rect ( 0 , 75 , 400 , 10 ) canvas . fill_style = 'blue' ; canvas . fill_rect ( 0 , 100 , 400 , 10 ) canvas . fill_style = 'purple' ; canvas . fill_rect ( 0 , 125 , 400 , 10 ) canvas . fill_style = 'pink' ; canvas . fill_rect ( 0 , 150 , 400 , 10 ) canvas Experiments Can you modify the above to use a list of colors and a for loop? The color list might be: Using Lists from ipycanvas import Canvas canvas = Canvas ( width = 400 , height = 250 ) colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'brown' , 'cyan' , 'lightgreen' , 'lightblue' ] canvas . font = '16px serif' # draw some boxes of different colors canvas . translate ( 10 , 10 ) for i in range ( len ( colors )): canvas . fill_style = colors [ i ]; canvas . fill_text ( colors [ i ], 0 , 25 * i + 10 ) canvas . fill_rect ( 70 , i * 25 , 400 , 15 ) canvas","title":"Canvas Color Bars"},{"location":"jupyter/20-canvas-color-bars/#canvas-color-bars","text":"We can draw directly into the Jupyter Lab canvas by using the Canvas drawing component. The following draws several horizontal bars of different color. from ipycanvas import Canvas canvas = Canvas ( width = 400 , height = 170 ) # draw a some lines of different colors and widths canvas . translate ( 10 , 10 ) canvas . fill_style = 'red' ; canvas . fill_rect ( 0 , 0 , 400 , 10 ) canvas . fill_style = 'orange' ; canvas . fill_rect ( 0 , 25 , 400 , 10 ) canvas . fill_style = 'yellow' ; canvas . fill_rect ( 0 , 50 , 400 , 10 ) canvas . fill_style = 'green' ; canvas . fill_rect ( 0 , 75 , 400 , 10 ) canvas . fill_style = 'blue' ; canvas . fill_rect ( 0 , 100 , 400 , 10 ) canvas . fill_style = 'purple' ; canvas . fill_rect ( 0 , 125 , 400 , 10 ) canvas . fill_style = 'pink' ; canvas . fill_rect ( 0 , 150 , 400 , 10 ) canvas","title":"Canvas Color Bars"},{"location":"jupyter/20-canvas-color-bars/#experiments","text":"Can you modify the above to use a list of colors and a for loop? The color list might be:","title":"Experiments"},{"location":"jupyter/20-canvas-color-bars/#using-lists","text":"from ipycanvas import Canvas canvas = Canvas ( width = 400 , height = 250 ) colors = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'brown' , 'cyan' , 'lightgreen' , 'lightblue' ] canvas . font = '16px serif' # draw some boxes of different colors canvas . translate ( 10 , 10 ) for i in range ( len ( colors )): canvas . fill_style = colors [ i ]; canvas . fill_text ( colors [ i ], 0 , 25 * i + 10 ) canvas . fill_rect ( 70 , i * 25 , 400 , 15 ) canvas","title":"Using Lists"},{"location":"pi/01-intro/","text":"Learning Python on Raspberry Pi Raspberry Pi Foundation Projects CoderDojo Pages on the Pi Site Thonny Thonny is a Integrated Development Environment for debugging Python code. Unfortunatly, no turtle graphics are supported. Adafruit CircuitPython CircuitPython is a programming language designed to simplify experimenting and learning to program on low-cost microcontroller boards. Learning Python with Raspberry Pi Book Sparkfun Tutorial Controlling LED Strips with Python","title":"Python on Raspberry Pi"},{"location":"pi/01-intro/#learning-python-on-raspberry-pi","text":"Raspberry Pi Foundation Projects CoderDojo Pages on the Pi Site Thonny Thonny is a Integrated Development Environment for debugging Python code. Unfortunatly, no turtle graphics are supported. Adafruit CircuitPython CircuitPython is a programming language designed to simplify experimenting and learning to program on low-cost microcontroller boards. Learning Python with Raspberry Pi Book Sparkfun Tutorial Controlling LED Strips with Python","title":"Learning Python on Raspberry Pi"},{"location":"repl/02-square/","text":"Square on Repl.it import turtle t = turtle . Turtle () t . fd ( 100 ) t . rt ( 90 ) t . fd ( 100 ) t . rt ( 90 ) t . fd ( 100 ) t . rt ( 90 ) t . fd ( 100 ) t . rt ( 90 ) Sample Square Program on Repl.it","title":"Square"},{"location":"repl/02-square/#square-on-replit","text":"import turtle t = turtle . Turtle () t . fd ( 100 ) t . rt ( 90 ) t . fd ( 100 ) t . rt ( 90 ) t . fd ( 100 ) t . rt ( 90 ) t . fd ( 100 ) t . rt ( 90 ) Sample Square Program on Repl.it","title":"Square on Repl.it"},{"location":"repl/07-flower/","text":"Flower using Petal Function on Repl.it import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 100 angle = 120 def petal (): if i % 2 : dan . color ( 'green' ) else : dan . color ( 'lightgreen' ) dan . left ( 30 ) # draw a triangle and fill in the color dan . begin_fill () dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . end_fill () dan . left ( angle ) # start off 45 right dan . right ( 45 ) # repeat the forward/right functions four times for i in range ( 4 ): petal () # now draw the stem dan . pensize ( 10 ) dan . right ( 45 ) dan . forward ( 200 ) Sample Square Program on Repl.it","title":"Flower"},{"location":"repl/07-flower/#flower-using-petal-function-on-replit","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 100 angle = 120 def petal (): if i % 2 : dan . color ( 'green' ) else : dan . color ( 'lightgreen' ) dan . left ( 30 ) # draw a triangle and fill in the color dan . begin_fill () dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . end_fill () dan . left ( angle ) # start off 45 right dan . right ( 45 ) # repeat the forward/right functions four times for i in range ( 4 ): petal () # now draw the stem dan . pensize ( 10 ) dan . right ( 45 ) dan . forward ( 200 ) Sample Square Program on Repl.it","title":"Flower using Petal Function on Repl.it"},{"location":"repl/12-recursion/","text":"Recursion Recursion is when we write a function that calls itself. It usually passes a parameter that changes and when it hits a limit it stops going. This lab does a lot of drawing so to speed it up we will disable the turtle motion. Our recursive function is the draw_branch function. It will draw a single branch and then call itself two times at its tip to draw two more smaller branches. Sample Code import turtle colorList = [ 'red' , 'orange' , 'green' , 'blue' , 'indigo' , 'violet' , 'brown' ] def draw_branch ( turtle , color , size , level ): if level > 1 : turtle . pendown () turtle . color ( color ) turtle . forward ( size ) turtle . right ( 20 ) # draw three branches at half length with a branch on the tip of each branch for i in range ( 0 , 3 ): turtle . forward ( size / 2 ) draw_branch ( turtle , colorList [ i ], size / 2 , level - 1 ) turtle . backward ( size / 2 ) turtle . left ( 20 ) turtle . right ( 40 ) turtle . backward ( size ) myTurtle = turtle . Turtle () myTurtle . shape ( \"turtle\" ) myTurtle . speed ( 50 ) length = 150 numberPetals = 6 myTurtle . penup () # move to the bottom center myTurtle . goto ( 0 , - 200 ) myTurtle . left ( 90 ) draw_branch ( myTurtle , colorList [ 0 ], length , 4 ) Drawing Link to Program on Repl.it Link to Program on Repl.it Explanation The first three lines will be the same for all our programs. They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon. Note that at the start, the turtle is facing to the right. After the last instruction, it is also facing to the right. Experiments Can you change the distance and angle the turtle moves? What happens when you change the numbers for the forward and right functions? Can you go left as well as right? Can you add more motion commands using copy and paste?","title":"Recursion"},{"location":"repl/12-recursion/#recursion","text":"Recursion is when we write a function that calls itself. It usually passes a parameter that changes and when it hits a limit it stops going. This lab does a lot of drawing so to speed it up we will disable the turtle motion. Our recursive function is the draw_branch function. It will draw a single branch and then call itself two times at its tip to draw two more smaller branches.","title":"Recursion"},{"location":"repl/12-recursion/#sample-code","text":"import turtle colorList = [ 'red' , 'orange' , 'green' , 'blue' , 'indigo' , 'violet' , 'brown' ] def draw_branch ( turtle , color , size , level ): if level > 1 : turtle . pendown () turtle . color ( color ) turtle . forward ( size ) turtle . right ( 20 ) # draw three branches at half length with a branch on the tip of each branch for i in range ( 0 , 3 ): turtle . forward ( size / 2 ) draw_branch ( turtle , colorList [ i ], size / 2 , level - 1 ) turtle . backward ( size / 2 ) turtle . left ( 20 ) turtle . right ( 40 ) turtle . backward ( size ) myTurtle = turtle . Turtle () myTurtle . shape ( \"turtle\" ) myTurtle . speed ( 50 ) length = 150 numberPetals = 6 myTurtle . penup () # move to the bottom center myTurtle . goto ( 0 , - 200 ) myTurtle . left ( 90 ) draw_branch ( myTurtle , colorList [ 0 ], length , 4 )","title":"Sample Code"},{"location":"repl/12-recursion/#drawing","text":"","title":"Drawing"},{"location":"repl/12-recursion/#link-to-program-on-replit","text":"Link to Program on Repl.it","title":"Link to Program on Repl.it"},{"location":"repl/12-recursion/#explanation","text":"The first three lines will be the same for all our programs. They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon. Note that at the start, the turtle is facing to the right. After the last instruction, it is also facing to the right.","title":"Explanation"},{"location":"repl/12-recursion/#experiments","text":"Can you change the distance and angle the turtle moves? What happens when you change the numbers for the forward and right functions? Can you go left as well as right? Can you add more motion commands using copy and paste?","title":"Experiments"},{"location":"trinket/00-introduction/","text":"Introduction Introduction to Turtle Graphics with Trinket These labs assume that you have internet access and a modern web browser such as Chrome. We use the Trinket web site because it has many of the basic turtle drawing libraries implemented in and easy-to-use web environment. It is appropriate for students just getting started with python programming but has limited libraries for our advanced data analysis and plotting labs. The free version is limited to the older Python 2.X functionality. If you want to try another web-based system that support turtle graphics and Python 3.X we suggest the web site repl.it Beginning Python Journey Map List of Trinket Python Learning Labs For students that are new to programming, here are some sample programs (what we call learning labs) that you can try. You can learn by reading the sample programs, going to the Trinkit.io site and changing some values in the code. Each of the labs has experiments at the end you can do to extend to see if you have mastered the concepts before you go on to the next lab. Turtle graphics - introduction to the Turtle Graphs library with a list of drawing functions Simple square - draw a square by moving and turning right four times Variables - add variables for the move edge distance and angle Loops - add a loop to make our code smaller Conditionals - add an if statement to change the color Functions - create a shape function Function parameters - add parameters to our function Random - generate random numbers Lists - store a list of colors Inputs - get some input from the user Recursion - create a function that calls itself Additional Labs In addition to our core labs, here are a few other labs that your students might find fun:","title":"Introduction"},{"location":"trinket/00-introduction/#introduction","text":"","title":"Introduction"},{"location":"trinket/00-introduction/#introduction-to-turtle-graphics-with-trinket","text":"These labs assume that you have internet access and a modern web browser such as Chrome. We use the Trinket web site because it has many of the basic turtle drawing libraries implemented in and easy-to-use web environment. It is appropriate for students just getting started with python programming but has limited libraries for our advanced data analysis and plotting labs. The free version is limited to the older Python 2.X functionality. If you want to try another web-based system that support turtle graphics and Python 3.X we suggest the web site repl.it","title":"Introduction to Turtle Graphics with Trinket"},{"location":"trinket/00-introduction/#beginning-python-journey-map","text":"","title":"Beginning Python Journey Map"},{"location":"trinket/00-introduction/#list-of-trinket-python-learning-labs","text":"For students that are new to programming, here are some sample programs (what we call learning labs) that you can try. You can learn by reading the sample programs, going to the Trinkit.io site and changing some values in the code. Each of the labs has experiments at the end you can do to extend to see if you have mastered the concepts before you go on to the next lab. Turtle graphics - introduction to the Turtle Graphs library with a list of drawing functions Simple square - draw a square by moving and turning right four times Variables - add variables for the move edge distance and angle Loops - add a loop to make our code smaller Conditionals - add an if statement to change the color Functions - create a shape function Function parameters - add parameters to our function Random - generate random numbers Lists - store a list of colors Inputs - get some input from the user Recursion - create a function that calls itself","title":"List of Trinket Python Learning Labs"},{"location":"trinket/00-introduction/#additional-labs","text":"In addition to our core labs, here are a few other labs that your students might find fun:","title":"Additional Labs"},{"location":"trinket/01-turtle-graphics/","text":"Trinket Account Before you begin, we would like you to go to the Trinket web site and create your own account. This will allow you to save your programs and come back later and continue working on them. Here is the link to the Trinket web site: https://trinket.io/ Be sure to bookmark this site for future reference. What is the turtle graphics library? Turtle graphs have been around for almost 50 years . A turtle is a drawing object that has position, direction, and a pen to draw as it moves around a grid. Turtle graphics are the preferred way to teach many concepts in computer science because they give you fast feedback. Fast feedback allows you to quickly see the errors in your code and correct them. For many of our introductory python labs, we will use the turtle python library. Although there are many different versions of the turtle library, most of the commands are similar. What you learn with the trinket python system will be useful in other systems also. Initialization commands There are three lines that will appear at the top of these labs: import turtle t = turtle . Turtle () t . shape ( 'turtle' ) The first line loads the turtle library into our program. The second creates a new turtle object called \"t\". The third line sets the shape to be a turtle. You don't have to use the name \"t\". You can set your turtle's name to be whatever you want. For example you can call your turtle \"sue\". import turtle sue = turtle . Turtle () sue . shape ( 'turtle' ) Just make sure you change all the names in the file to reference your new name. Moving the Turtle There are five ways to move your turtle around the screen. Our screen is around 400 points wide and 400 points high. The point (0,0) is at the center of our screen. The first four are relative movement commands. The last one will move the turtle to the absolute x and y location. t.forward(40) t.back(40) t.left(90) t.right(90) t.goto(x,y) Drawing There are several ways to draw virtual \"ink\" on the screen. The most common way is to just move your turtle around. It will draw a thin black line by default, but you can also change the pen color and the width of drawing. t.penup() - no drawing will happen when the pen is up t.pendown() - drawing will occur on the screen when the turtle moves t.color('red') - set the pen to a specific color t.pensize(5) - set the width of the pen from 1 to 20. 5 is a good size. t.begin_fill() - begin filling a region you draw around t.end_fill() - end the fill region Shapes There are also a few built-in drawing functions. The circle function that takes a single radius is an example of this. - t.circle(10) Misc There are also a few other miscellaneous things you can do. You can do some drawing and then clear the screen. t.clear() - clears the screen of all drawing t.hideturtle() - hides the turtle on the screen You can see a full list of the turtle commands here . Just click on the turtle area and scroll down. Generating a random number In addition to these drawing commands some of the exercises use random numbers. Here is how we do this: import random # get a random number between -200 and 200 myNumber = random . randint ( - 200 , 200 ) This will generate a random number from -200 to 200. You can use this number to randomly place items on the drawing canvas. Now, let's get started doing some fun drawing!","title":"Trinket Account"},{"location":"trinket/01-turtle-graphics/#trinket-account","text":"Before you begin, we would like you to go to the Trinket web site and create your own account. This will allow you to save your programs and come back later and continue working on them. Here is the link to the Trinket web site: https://trinket.io/ Be sure to bookmark this site for future reference.","title":"Trinket Account"},{"location":"trinket/01-turtle-graphics/#what-is-the-turtle-graphics-library","text":"Turtle graphs have been around for almost 50 years . A turtle is a drawing object that has position, direction, and a pen to draw as it moves around a grid. Turtle graphics are the preferred way to teach many concepts in computer science because they give you fast feedback. Fast feedback allows you to quickly see the errors in your code and correct them. For many of our introductory python labs, we will use the turtle python library. Although there are many different versions of the turtle library, most of the commands are similar. What you learn with the trinket python system will be useful in other systems also.","title":"What is the turtle graphics library?"},{"location":"trinket/01-turtle-graphics/#initialization-commands","text":"There are three lines that will appear at the top of these labs: import turtle t = turtle . Turtle () t . shape ( 'turtle' ) The first line loads the turtle library into our program. The second creates a new turtle object called \"t\". The third line sets the shape to be a turtle. You don't have to use the name \"t\". You can set your turtle's name to be whatever you want. For example you can call your turtle \"sue\". import turtle sue = turtle . Turtle () sue . shape ( 'turtle' ) Just make sure you change all the names in the file to reference your new name.","title":"Initialization commands"},{"location":"trinket/01-turtle-graphics/#moving-the-turtle","text":"There are five ways to move your turtle around the screen. Our screen is around 400 points wide and 400 points high. The point (0,0) is at the center of our screen. The first four are relative movement commands. The last one will move the turtle to the absolute x and y location. t.forward(40) t.back(40) t.left(90) t.right(90) t.goto(x,y)","title":"Moving the Turtle"},{"location":"trinket/01-turtle-graphics/#drawing","text":"There are several ways to draw virtual \"ink\" on the screen. The most common way is to just move your turtle around. It will draw a thin black line by default, but you can also change the pen color and the width of drawing. t.penup() - no drawing will happen when the pen is up t.pendown() - drawing will occur on the screen when the turtle moves t.color('red') - set the pen to a specific color t.pensize(5) - set the width of the pen from 1 to 20. 5 is a good size. t.begin_fill() - begin filling a region you draw around t.end_fill() - end the fill region","title":"Drawing"},{"location":"trinket/01-turtle-graphics/#shapes","text":"There are also a few built-in drawing functions. The circle function that takes a single radius is an example of this. - t.circle(10)","title":"Shapes"},{"location":"trinket/01-turtle-graphics/#misc","text":"There are also a few other miscellaneous things you can do. You can do some drawing and then clear the screen. t.clear() - clears the screen of all drawing t.hideturtle() - hides the turtle on the screen You can see a full list of the turtle commands here . Just click on the turtle area and scroll down.","title":"Misc"},{"location":"trinket/01-turtle-graphics/#generating-a-random-number","text":"In addition to these drawing commands some of the exercises use random numbers. Here is how we do this: import random # get a random number between -200 and 200 myNumber = random . randint ( - 200 , 200 ) This will generate a random number from -200 to 200. You can use this number to randomly place items on the drawing canvas. Now, let's get started doing some fun drawing!","title":"Generating a random number"},{"location":"trinket/02-simple-square/","text":"Drawing a Square The following code is an example of drawing a square using turtle graphics. In this example the turtle moves foward 100 units and then turns right. The angle for the right turn is 90 degrees. It repeats these two functions four times to make a square. Sample Code import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) dan . forward ( 100 ) dan . right ( 90 ) dan . forward ( 100 ) dan . right ( 90 ) dan . forward ( 100 ) dan . right ( 90 ) dan . forward ( 100 ) dan . right ( 90 ) Drawing Try it out Here is a link to the Trinket web site with this program running: https://trinket.io/python/564899ffe9 You can click on this link and then press the Run button. You should see the python code on the left side and the drawing on the right side of your screen. Explaination The first three lines will be the same for all our programs. They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon. Although almost all the turtle libraries work this way, there are some minor differences you will see in future examples. Reorinenting your turtle Note that at the start, the turtle is facing to the right. After the last instruction, it is also facing to the right. This is a common best practice so that the turtle gets reoriented after some drawing function. If you remove the last right(90) function and run the program again you will see the turtle ends up facing upward. But if you rerun the progam you will still get the same square because the orientation of the turtle is not stored between runs. Experiments Can you change the distance and angle the turtle moves? What happens when you change the numbers for the forward and right functions? Can you go left as well as right? Can you add more motion commands using the copy and paste?","title":"Turtle Square"},{"location":"trinket/02-simple-square/#drawing-a-square","text":"The following code is an example of drawing a square using turtle graphics. In this example the turtle moves foward 100 units and then turns right. The angle for the right turn is 90 degrees. It repeats these two functions four times to make a square.","title":"Drawing a Square"},{"location":"trinket/02-simple-square/#sample-code","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) dan . forward ( 100 ) dan . right ( 90 ) dan . forward ( 100 ) dan . right ( 90 ) dan . forward ( 100 ) dan . right ( 90 ) dan . forward ( 100 ) dan . right ( 90 )","title":"Sample Code"},{"location":"trinket/02-simple-square/#drawing","text":"","title":"Drawing"},{"location":"trinket/02-simple-square/#try-it-out","text":"Here is a link to the Trinket web site with this program running: https://trinket.io/python/564899ffe9 You can click on this link and then press the Run button. You should see the python code on the left side and the drawing on the right side of your screen.","title":"Try it out"},{"location":"trinket/02-simple-square/#explaination","text":"The first three lines will be the same for all our programs. They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon. Although almost all the turtle libraries work this way, there are some minor differences you will see in future examples.","title":"Explaination"},{"location":"trinket/02-simple-square/#reorinenting-your-turtle","text":"Note that at the start, the turtle is facing to the right. After the last instruction, it is also facing to the right. This is a common best practice so that the turtle gets reoriented after some drawing function. If you remove the last right(90) function and run the program again you will see the turtle ends up facing upward. But if you rerun the progam you will still get the same square because the orientation of the turtle is not stored between runs.","title":"Reorinenting your turtle"},{"location":"trinket/02-simple-square/#experiments","text":"Can you change the distance and angle the turtle moves? What happens when you change the numbers for the forward and right functions? Can you go left as well as right? Can you add more motion commands using the copy and paste?","title":"Experiments"},{"location":"trinket/03-variables/","text":"Using Variables In the simple square program we repeated the numbers for the distance and turning angle four times in four different places. If we wanted to change the size of our box we would have to change the code in four different places. By using variables we can make our program easier to change. In this example program we will make the turtle go forward 40 steps and then make a right turn of 90 degrees. We will repeat this four times to complete a square. Sample Code import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) # let's just put these in one place to make our program easier to modify distance = 50 angle = 90 dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . write ( 'done with square' ) Run Square With Variables Experiments Can you make the turtle draw a larger square? Hint: change the forward(40) to be forward(100)","title":"Variables"},{"location":"trinket/03-variables/#using-variables","text":"In the simple square program we repeated the numbers for the distance and turning angle four times in four different places. If we wanted to change the size of our box we would have to change the code in four different places. By using variables we can make our program easier to change. In this example program we will make the turtle go forward 40 steps and then make a right turn of 90 degrees. We will repeat this four times to complete a square.","title":"Using Variables"},{"location":"trinket/03-variables/#sample-code","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) # let's just put these in one place to make our program easier to modify distance = 50 angle = 90 dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . write ( 'done with square' ) Run Square With Variables","title":"Sample Code"},{"location":"trinket/03-variables/#experiments","text":"Can you make the turtle draw a larger square? Hint: change the forward(40) to be forward(100)","title":"Experiments"},{"location":"trinket/04-loops/","text":"Using a Loop In this example program we will make the turtle go forward 40 steps and then make a right turn of 90 degrees. We will repeat this four times to complete a square. Sample Code import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 50 angle = 90 # repeat the forward/right functions four times for i in range ( 4 ): dan . forward ( distance ) dan . right ( angle ) dan . write ( 'done with square' ) Running the Demo Run Square With Loop Experiments Can you make the turtle draw a larger square? Hint: change the distance to be 80. How big can you make the square before the turtle goes off the screen?","title":"Loops"},{"location":"trinket/04-loops/#using-a-loop","text":"In this example program we will make the turtle go forward 40 steps and then make a right turn of 90 degrees. We will repeat this four times to complete a square.","title":"Using a Loop"},{"location":"trinket/04-loops/#sample-code","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 50 angle = 90 # repeat the forward/right functions four times for i in range ( 4 ): dan . forward ( distance ) dan . right ( angle ) dan . write ( 'done with square' )","title":"Sample Code"},{"location":"trinket/04-loops/#running-the-demo","text":"Run Square With Loop","title":"Running the Demo"},{"location":"trinket/04-loops/#experiments","text":"Can you make the turtle draw a larger square? Hint: change the distance to be 80. How big can you make the square before the turtle goes off the screen?","title":"Experiments"},{"location":"trinket/05-conditionals/","text":"Conditionals In this example program we will make the turtle draw different sides of the square using different colors. We would like every other side to change color. To do this we will add an if-then-else block of code to our example program. This block of code is called a conditional block. The condition is an expression that evaluates to be either TRUE for FALSE. In our example we will test to see if the index of our loop (the letter \"i\") is ODD or EVEN. We can do this by looking at the remainder after we divide by 2. Python has a handy operator called the modulo operator that uses the percent character which is above the number five on your keyboard. The test for ODD or EVEN is this: i % 2 In our previous loop lesson, we created an index that started at 1 and then changed to 2, 3 and finally 4. For 1 and 3, the first and third edges the result of divid by 2 will return 1 which is the same as TRUE. For 2 and 4 (the vertical sides of the square), the expression will evaluate to 0 since the remainder of 2/2 and 4/2 is zero. import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 50 angle = 90 # repeat the forward/right functions four times for i in range ( 4 ): if i % 2 : dan . color ( 'red' ) else : dan . color ( 'blue' ) dan . forward ( distance ) dan . right ( angle ) dan . write ( 'done with square' ) Conditinal Sqare Can you make the turtle use a larger pen size? Try dan.pensize(10) for the red and dan.pensize(3) for the blue. Experiments Can you change the width of the pen with the dan.penwidth(20) function?","title":"Conditional"},{"location":"trinket/05-conditionals/#conditionals","text":"In this example program we will make the turtle draw different sides of the square using different colors. We would like every other side to change color. To do this we will add an if-then-else block of code to our example program. This block of code is called a conditional block. The condition is an expression that evaluates to be either TRUE for FALSE. In our example we will test to see if the index of our loop (the letter \"i\") is ODD or EVEN. We can do this by looking at the remainder after we divide by 2. Python has a handy operator called the modulo operator that uses the percent character which is above the number five on your keyboard. The test for ODD or EVEN is this: i % 2 In our previous loop lesson, we created an index that started at 1 and then changed to 2, 3 and finally 4. For 1 and 3, the first and third edges the result of divid by 2 will return 1 which is the same as TRUE. For 2 and 4 (the vertical sides of the square), the expression will evaluate to 0 since the remainder of 2/2 and 4/2 is zero. import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 50 angle = 90 # repeat the forward/right functions four times for i in range ( 4 ): if i % 2 : dan . color ( 'red' ) else : dan . color ( 'blue' ) dan . forward ( distance ) dan . right ( angle ) dan . write ( 'done with square' ) Conditinal Sqare Can you make the turtle use a larger pen size? Try dan.pensize(10) for the red and dan.pensize(3) for the blue.","title":"Conditionals"},{"location":"trinket/05-conditionals/#experiments","text":"Can you change the width of the pen with the dan.penwidth(20) function?","title":"Experiments"},{"location":"trinket/06-functions/","text":"Functions Now we will create a new function that will draw each side. Sample Code import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 50 angle = 90 def side (): # if event then red 2, 4 etc. if i % 2 : dan . color ( 'red' ) # else if odd then draw blue 1, 3 etc. else : dan . color ( 'blue' ) dan . forward ( distance ) dan . right ( angle ) # repeat the forward/right functions four times for i in range ( 4 ): side () dan . write ( 'done with square' ) Function Experiments Can you change the name of the function to be \"petal\"?","title":"Functions"},{"location":"trinket/06-functions/#functions","text":"Now we will create a new function that will draw each side.","title":"Functions"},{"location":"trinket/06-functions/#sample-code","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 50 angle = 90 def side (): # if event then red 2, 4 etc. if i % 2 : dan . color ( 'red' ) # else if odd then draw blue 1, 3 etc. else : dan . color ( 'blue' ) dan . forward ( distance ) dan . right ( angle ) # repeat the forward/right functions four times for i in range ( 4 ): side () dan . write ( 'done with square' ) Function","title":"Sample Code"},{"location":"trinket/06-functions/#experiments","text":"Can you change the name of the function to be \"petal\"?","title":"Experiments"},{"location":"trinket/07-flower/","text":"Flower Now we will create a new function that will draw a triangle for each side. It will do this by going forward and right three times at an angle of 120 degrees. We will put that triangle into a function called petal. We will then call that function four times. At the end we will draw the stem. To make the stem wider we will change the pen size. Sample Code import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 100 angle = 120 def petal (): if i % 2 : dan . color ( 'green' ) else : dan . color ( 'lightgreen' ) dan . left ( 30 ) # draw a triangle and fill in the color dan . begin_fill () dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . end_fill () dan . left ( angle ) # start off 45 right dan . right ( 45 ) # repeat the forward/right functions four times for i in range ( 4 ): petal () # now draw the stem dan . pensize ( 10 ) dan . right ( 45 ) dan . forward ( 200 ) dan . write ( 'done with flower' ) Drawing Run the Example Function Experiments Can you change the colors of the petals? Can you change the width of the stem of the flower using the pensize() function? Can you change the size of the petals? Can you change the number of petals?","title":"Flower"},{"location":"trinket/07-flower/#flower","text":"Now we will create a new function that will draw a triangle for each side. It will do this by going forward and right three times at an angle of 120 degrees. We will put that triangle into a function called petal. We will then call that function four times. At the end we will draw the stem. To make the stem wider we will change the pen size.","title":"Flower"},{"location":"trinket/07-flower/#sample-code","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) distance = 100 angle = 120 def petal (): if i % 2 : dan . color ( 'green' ) else : dan . color ( 'lightgreen' ) dan . left ( 30 ) # draw a triangle and fill in the color dan . begin_fill () dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . right ( angle ) dan . forward ( distance ) dan . end_fill () dan . left ( angle ) # start off 45 right dan . right ( 45 ) # repeat the forward/right functions four times for i in range ( 4 ): petal () # now draw the stem dan . pensize ( 10 ) dan . right ( 45 ) dan . forward ( 200 ) dan . write ( 'done with flower' )","title":"Sample Code"},{"location":"trinket/07-flower/#drawing","text":"","title":"Drawing"},{"location":"trinket/07-flower/#run-the-example","text":"Function","title":"Run the Example"},{"location":"trinket/07-flower/#experiments","text":"Can you change the colors of the petals? Can you change the width of the stem of the flower using the pensize() function? Can you change the size of the petals? Can you change the number of petals?","title":"Experiments"},{"location":"trinket/07-function-parameters/","text":"Function= Parameters Now we will create a new function that draw a square with a specific color at a specific x and y point. The function will take three inputs: - the color - the horizontal x position on the grid - the vertical y position on the grid Sample Code import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) size = 40 angle = 90 def square ( myColor , x , y ): dan . color ( myColor ) dan . penup () dan . goto ( x , y ) dan . pendown () for i in range ( 4 ): dan . forward ( size ) dan . right ( angle ) square ( 'red' , - 50 , 80 ) square ( 'orange' , 50 , 70 ) square ( 'green' , - 50 , - 20 ) square ( 'blue' , 70 , - 50 ) Drawing Function Experiments Can you change the name of the function to be \"petal\"?","title":"Function Parameters"},{"location":"trinket/07-function-parameters/#function-parameters","text":"Now we will create a new function that draw a square with a specific color at a specific x and y point. The function will take three inputs: - the color - the horizontal x position on the grid - the vertical y position on the grid","title":"Function= Parameters"},{"location":"trinket/07-function-parameters/#sample-code","text":"import turtle dan = turtle . Turtle () dan . shape ( 'turtle' ) size = 40 angle = 90 def square ( myColor , x , y ): dan . color ( myColor ) dan . penup () dan . goto ( x , y ) dan . pendown () for i in range ( 4 ): dan . forward ( size ) dan . right ( angle ) square ( 'red' , - 50 , 80 ) square ( 'orange' , 50 , 70 ) square ( 'green' , - 50 , - 20 ) square ( 'blue' , 70 , - 50 )","title":"Sample Code"},{"location":"trinket/07-function-parameters/#drawing","text":"Function","title":"Drawing"},{"location":"trinket/07-function-parameters/#experiments","text":"Can you change the name of the function to be \"petal\"?","title":"Experiments"},{"location":"trinket/08-list/","text":"Python List How would we create and access a list of colors in Python? Here is a list of colors: colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] To access any color you can reference the index of the color by using a number. For example to get the third color you would use: colorList [ 2 ] Sample Code to Draw A Circle with a Color Index import turtle import random dan = turtle . Turtle () dan . shape ( 'turtle' ) colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] dan . begin_fill () dan . color ( colorList [ 3 ]) dan . circle ( 20 ) dan . end_fill () Drawing Run Sample Program on Trinket Draw a Green Circle Using List Experiments Can you change the name of the function to be \"petal\"?","title":"Lists"},{"location":"trinket/08-list/#python-list","text":"How would we create and access a list of colors in Python? Here is a list of colors: colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] To access any color you can reference the index of the color by using a number. For example to get the third color you would use: colorList [ 2 ]","title":"Python List"},{"location":"trinket/08-list/#sample-code-to-draw-a-circle-with-a-color-index","text":"import turtle import random dan = turtle . Turtle () dan . shape ( 'turtle' ) colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] dan . begin_fill () dan . color ( colorList [ 3 ]) dan . circle ( 20 ) dan . end_fill ()","title":"Sample Code to Draw A Circle with a Color Index"},{"location":"trinket/08-list/#drawing","text":"","title":"Drawing"},{"location":"trinket/08-list/#run-sample-program-on-trinket","text":"Draw a Green Circle Using List","title":"Run Sample Program on Trinket"},{"location":"trinket/08-list/#experiments","text":"Can you change the name of the function to be \"petal\"?","title":"Experiments"},{"location":"trinket/08-random/","text":"Random Circles In this exercise we will draw 10 random circles on the screen. We will use the random function randint(min, max) that will generate a random number between the minimum and maximum values. Since we are drawing on a grid that goes from -200 to 200 here is the random function: myNumber = random.randint(-200, 200) After this line runs, the variable myNumber will be assigned some random number between -200 and 200. We will then use this number to go to that location before we draw a circle. Sample Code import turtle import random # this is a list of colors colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] dan = turtle . Turtle () dan . shape ( 'turtle' ) # draw a circle at a random location on the screen for i in range ( 10 ): x = random . randint ( - 200 , 200 ) y = random . randint ( - 200 , 200 ) dan . goto ( x , y ) # pick a random color from the colorList by getting a random index from 0 to 9 dan . color ( colorList [ random . randint ( 0 , 9 )]) # draw a circle with radius of 7 units dan . begin_fill () dan . circle ( 7 ) dan . end_fill () dan . goto ( 0 , 0 ) Drawing Draw 10 circles example on Trinket Experiments Can you create a variable that is used to control the distance from the origin to wander? Right now the distance is set to be 200 on each extent. Can you create a variable for the number of circles to draw? Go to the Trinket colors page and see the name of other colors you can use. Note that you can use","title":"Random Numbers"},{"location":"trinket/08-random/#random-circles","text":"In this exercise we will draw 10 random circles on the screen. We will use the random function randint(min, max) that will generate a random number between the minimum and maximum values. Since we are drawing on a grid that goes from -200 to 200 here is the random function: myNumber = random.randint(-200, 200) After this line runs, the variable myNumber will be assigned some random number between -200 and 200. We will then use this number to go to that location before we draw a circle.","title":"Random Circles"},{"location":"trinket/08-random/#sample-code","text":"import turtle import random # this is a list of colors colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] dan = turtle . Turtle () dan . shape ( 'turtle' ) # draw a circle at a random location on the screen for i in range ( 10 ): x = random . randint ( - 200 , 200 ) y = random . randint ( - 200 , 200 ) dan . goto ( x , y ) # pick a random color from the colorList by getting a random index from 0 to 9 dan . color ( colorList [ random . randint ( 0 , 9 )]) # draw a circle with radius of 7 units dan . begin_fill () dan . circle ( 7 ) dan . end_fill () dan . goto ( 0 , 0 )","title":"Sample Code"},{"location":"trinket/08-random/#drawing","text":"Draw 10 circles example on Trinket","title":"Drawing"},{"location":"trinket/08-random/#experiments","text":"Can you create a variable that is used to control the distance from the origin to wander? Right now the distance is set to be 200 on each extent. Can you create a variable for the number of circles to draw? Go to the Trinket colors page and see the name of other colors you can use. Note that you can use","title":"Experiments"},{"location":"trinket/11-input/","text":"Input We can prompt the user to supply a number using the input() function. import turtle import random dan = turtle . Turtle () dan . shape ( 'turtle' ) colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] colorIndexInt = 0 while colorIndexInt > - 1 : colorIndexString = input ( \"Enter a number from 0 to 9 to set the new color:\" ) colorIndexInt = int ( colorIndexString ) dan . begin_fill () dan . color ( colorList [ colorIndexInt ]) dan . circle ( 20 ) dan . end_fill () dan . write ( 'done!' ) Example on Trinket Run Example","title":"Input"},{"location":"trinket/11-input/#input","text":"We can prompt the user to supply a number using the input() function. import turtle import random dan = turtle . Turtle () dan . shape ( 'turtle' ) colorList = [ 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'purple' , 'pink' , 'brown' , 'gray' , 'gold' ] colorIndexInt = 0 while colorIndexInt > - 1 : colorIndexString = input ( \"Enter a number from 0 to 9 to set the new color:\" ) colorIndexInt = int ( colorIndexString ) dan . begin_fill () dan . color ( colorList [ colorIndexInt ]) dan . circle ( 20 ) dan . end_fill () dan . write ( 'done!' )","title":"Input"},{"location":"trinket/11-input/#example-on-trinket","text":"Run Example","title":"Example on Trinket"},{"location":"trinket/12-recursion/","text":"Recursion Recursion is when we write a function that calls itself. It usually passes a parameter that changes and when it hits a limit it stops going. This lab does a lot of drawing so to speed it up we will disable the turtle motion. Our recursive function is the draw_branch function. It will draw a single branch and then call itself two times at its tip to draw two more smaller branches. Sample Code import turtle colorList = [ 'red' , 'orange' , 'green' , 'blue' , 'indigo' , 'violet' , 'brown' ] def draw_branch ( turtle , color , size , level ): if level > 1 : turtle . pendown () turtle . color ( color ) turtle . forward ( size ) turtle . right ( 20 ) # draw three branches at half length with a branch on the tip of each branch for i in range ( 0 , 3 ): turtle . forward ( size / 2 ) draw_branch ( turtle , colorList [ i ], size / 2 , level - 1 ) turtle . backward ( size / 2 ) turtle . left ( 20 ) turtle . right ( 40 ) turtle . backward ( size ) myTurtle = turtle . Turtle () myTurtle . shape ( \"turtle\" ) myTurtle . speed ( 50 ) length = 150 numberPetals = 6 myTurtle . penup () # move to the bottom center myTurtle . goto ( 0 , - 200 ) myTurtle . left ( 90 ) draw_branch ( myTurtle , colorList [ 0 ], length , 4 ) Drawing Link to Program on Trinket Link to Program on Trinket Explanation The first three lines will be the same for all our programs. They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon. Note that at the start, the turtle is facing to the right. After the last instruction, it is also facing to the right. Experiments Can you change the distance and angle the turtle moves? What happens when you change the numbers for the forward and right functions? Can you go left as well as right? Can you add more motion commands using copy and paste?","title":"Recursion"},{"location":"trinket/12-recursion/#recursion","text":"Recursion is when we write a function that calls itself. It usually passes a parameter that changes and when it hits a limit it stops going. This lab does a lot of drawing so to speed it up we will disable the turtle motion. Our recursive function is the draw_branch function. It will draw a single branch and then call itself two times at its tip to draw two more smaller branches.","title":"Recursion"},{"location":"trinket/12-recursion/#sample-code","text":"import turtle colorList = [ 'red' , 'orange' , 'green' , 'blue' , 'indigo' , 'violet' , 'brown' ] def draw_branch ( turtle , color , size , level ): if level > 1 : turtle . pendown () turtle . color ( color ) turtle . forward ( size ) turtle . right ( 20 ) # draw three branches at half length with a branch on the tip of each branch for i in range ( 0 , 3 ): turtle . forward ( size / 2 ) draw_branch ( turtle , colorList [ i ], size / 2 , level - 1 ) turtle . backward ( size / 2 ) turtle . left ( 20 ) turtle . right ( 40 ) turtle . backward ( size ) myTurtle = turtle . Turtle () myTurtle . shape ( \"turtle\" ) myTurtle . speed ( 50 ) length = 150 numberPetals = 6 myTurtle . penup () # move to the bottom center myTurtle . goto ( 0 , - 200 ) myTurtle . left ( 90 ) draw_branch ( myTurtle , colorList [ 0 ], length , 4 )","title":"Sample Code"},{"location":"trinket/12-recursion/#drawing","text":"","title":"Drawing"},{"location":"trinket/12-recursion/#link-to-program-on-trinket","text":"Link to Program on Trinket","title":"Link to Program on Trinket"},{"location":"trinket/12-recursion/#explanation","text":"The first three lines will be the same for all our programs. They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon. Note that at the start, the turtle is facing to the right. After the last instruction, it is also facing to the right.","title":"Explanation"},{"location":"trinket/12-recursion/#experiments","text":"Can you change the distance and angle the turtle moves? What happens when you change the numbers for the forward and right functions? Can you go left as well as right? Can you add more motion commands using copy and paste?","title":"Experiments"},{"location":"trinket/13-random-stars/","text":"import turtle import random this is a list of colors colorList = ['red', 'orange', 'green', 'blue', 'purple', 'pink', 'brown', 'gray', 'gold'] dan = turtle.Turtle() dan.shape('turtle') dan.delay(1) dan.clear() dan.penup() max_distance = 160 draw an eight sided star def star(x, y, size, color): dan.goto(x, y) dan.color(colorList[random.randint(0,len(colorList)-1)]) dan.pendown() dan.begin_fill() for i in range(1,8): dan.forward(size) dan.right(150) dan.forward(size) dan.left(100) dan.end_fill() dan.right(10) dan.penup() draw a pattern at a random location on the screen for i in range(5): x = random.randint(-max_distance, max_distance) y = random.randint(-max_distance, max_distance) size = random.randint(15, 30) color_index = random.randint(0,8) # draw a star with size and color star(x,y,size, color_index) hide so we have a nice drawing dan.hideturtle()","title":"Random Stars"},{"location":"trinket/13-random-stars/#this-is-a-list-of-colors","text":"colorList = ['red', 'orange', 'green', 'blue', 'purple', 'pink', 'brown', 'gray', 'gold'] dan = turtle.Turtle() dan.shape('turtle') dan.delay(1) dan.clear() dan.penup() max_distance = 160","title":"this is a list of colors"},{"location":"trinket/13-random-stars/#draw-an-eight-sided-star","text":"def star(x, y, size, color): dan.goto(x, y) dan.color(colorList[random.randint(0,len(colorList)-1)]) dan.pendown() dan.begin_fill() for i in range(1,8): dan.forward(size) dan.right(150) dan.forward(size) dan.left(100) dan.end_fill() dan.right(10) dan.penup()","title":"draw an eight sided star"},{"location":"trinket/13-random-stars/#draw-a-pattern-at-a-random-location-on-the-screen","text":"for i in range(5): x = random.randint(-max_distance, max_distance) y = random.randint(-max_distance, max_distance) size = random.randint(15, 30) color_index = random.randint(0,8) # draw a star with size and color star(x,y,size, color_index)","title":"draw a pattern at a random location on the screen"},{"location":"trinket/13-random-stars/#hide-so-we-have-a-nice-drawing","text":"dan.hideturtle()","title":"hide so we have a nice drawing"},{"location":"trinket/13-shape-module/","text":"Shape Module In this lab we will create a set of drawing function and put them together into a new file. We will then import this file into our main.py file. Sample Code # This is a custom module we've made. # Modules are files full of code that you can import into your programs. # This one teaches our turtle to draw various shapes. import turtle def draw_circle ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () turtle . circle ( size ) turtle . end_fill () def draw_triangle ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () for i in range ( 3 ): turtle . forward ( size * 3 ) turtle . left ( 120 ) turtle . end_fill () turtle . setheading ( 0 ) def draw_square ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () for i in range ( 4 ): turtle . forward ( size * 2 ) turtle . left ( 90 ) turtle . end_fill () turtle . setheading ( 0 ) def draw_star ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () turtle . right ( 144 ) for i in range ( 5 ): turtle . forward ( size * 2 ) turtle . right ( 144 ) turtle . forward ( size * 2 ) turtle . end_fill () turtle . setheading ( 0 ) Sample Program Sample Experiments Can you add a new shape called \"flower\"?","title":"13 shape module"},{"location":"trinket/13-shape-module/#shape-module","text":"In this lab we will create a set of drawing function and put them together into a new file. We will then import this file into our main.py file.","title":"Shape Module"},{"location":"trinket/13-shape-module/#sample-code","text":"# This is a custom module we've made. # Modules are files full of code that you can import into your programs. # This one teaches our turtle to draw various shapes. import turtle def draw_circle ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () turtle . circle ( size ) turtle . end_fill () def draw_triangle ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () for i in range ( 3 ): turtle . forward ( size * 3 ) turtle . left ( 120 ) turtle . end_fill () turtle . setheading ( 0 ) def draw_square ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () for i in range ( 4 ): turtle . forward ( size * 2 ) turtle . left ( 90 ) turtle . end_fill () turtle . setheading ( 0 ) def draw_star ( turtle , color , size , x , y ): turtle . penup () turtle . color ( color ) turtle . fillcolor ( color ) turtle . goto ( x , y ) turtle . pendown () turtle . begin_fill () turtle . right ( 144 ) for i in range ( 5 ): turtle . forward ( size * 2 ) turtle . right ( 144 ) turtle . forward ( size * 2 ) turtle . end_fill () turtle . setheading ( 0 )","title":"Sample Code"},{"location":"trinket/13-shape-module/#sample-program","text":"Sample","title":"Sample Program"},{"location":"trinket/13-shape-module/#experiments","text":"Can you add a new shape called \"flower\"?","title":"Experiments"},{"location":"trinket/14-color-picker/","text":"Color Picker Color Picker","title":"14 color picker"},{"location":"trinket/14-color-picker/#color-picker","text":"Color Picker","title":"Color Picker"}]}